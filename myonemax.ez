/*_________________________________________________________

    onemax.ez

    EASEA implementation of the ONEMAX problem       

    Pierre COLLET (Pierre.Collet@Polytechnique.Fr)

    17/01/01
__________________________________________________________*/

\User classes :
GenomeClass { bool genes[10]; }
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  for (int i=0;i<10;i++) Genome.genes[i]=tossCoin(.5)?1:0;
\end

\GenomeClass::crossover :
  int CrossoverPosition=random(0,10);
  bool b;
  for(int i=0;i<CrossoverPosition+1;i++)
      {b=child1.genes[i]; child1.genes[i]=child2.genes[i]); child2.genes[i]=b;}
\end

\GenomeClass::mutator : // Must hand back the number of mutations
  int NbMut=0;
  for (int i=0;i<10;i++)
    if (tossCoin(pMutPerGene)){
       NbMut++;
       Genome.genes[i]=Genome.genes[i]?0:1;
    }
  return NbMut;
\end

\GenomeClass::evaluator : // Returns the score
  int Score=0;         
  for (int i=0; i<10;i++)
    Score+=(int)Genome.genes[i];
  return Score;
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 15     // NB_GEN
  Mutation probability : 1       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Population size : 30           // POP_SIZE
  Selection operator : Tournament // RouletteWheel, Deterministic, Ranking, Random
  Offspring population size : 12 // 40% 
  Replacement strategy : Plus    // Comma, SteadyState, Generational
  Discarding operator : Worst    // Best, Tournament, Parent, Random
  Evaluator goal : Maximise      // Minimise
  Elitism : On                   // Off
\end
