\User declarations:
#define SIZE 100      
float pMutPerGene=0.1;

inline void swap(bool& a, bool& b)
  {bool c=a; a=b; b=c;}
\end

\User functions:

\end

\Initialisation function:

\end

\User classes:
GenomeClass
{
  bool x[SIZE]; 
}
\end

\GenomeClass::initialiser:
  for (int i=0;i<SIZE;i++) Genome.x[i]=tossCoin(.5)?1:0;
\end

\GenomeClass::crossover:
  int CrossoverPosition=random(0,SIZE);

  for(int i=0;i<CrossoverPosition+1;i++)
    swap(child1.x[i],child2.x[i]);
\end

\GenomeClass::mutator:
  int NbMut=0;
  for (int i=0;i<SIZE;i++)
    if (tossCoin(pMutPerGene)){
       NbMut++;
       Genome.x[i]=Genome.x[i]?0:1;
    }
  return NbMut;
\end

\GenomeClass::evaluator:
  int Score=0;         
  for (int i=0; i<SIZE;i++)
    Score+=(int)Genome.x[i];
  return Score;
\end

\GenomeClass::display:

\end

\At each new generation:

\end

\Default run parameters:

// Variation operators
  Mutation probability: 0.3
  Crossover probability: 0.8

// Evolution Engine:
  Evaluator goal: Minimise       // or maximise
  Number of generations: 2000
  Population: 100
  Elite: 1 
  Genitors: 80                   // those who can be parents
  Genitors selector: sequential
  Parents selector: Tournament 2 // Selection of a parent to create a child
  Offspring: 100
  Reduce parents: Tournament 2
  Surviving parents: 20
  Reduce offspring: Tournament 2
  Surviving offspring: 80
  Final reduce: Tournament 2
  Elitism: Strong
\end
