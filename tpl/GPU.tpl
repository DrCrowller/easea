\TEMPLATE_START// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEA.cpp
//                                         
//  C++ file generated by AESAE-CUDA v0.9a
//                                         
//****************************************


\ANALYSE_PARAMETERS
#include <unistd.h>
#include "outputea.h"
#include <stdio.h>
#include "tool.h"
#include "krnl.h"

#define TAILLE_POP \POP_SIZE
#define TAILLE_POP_ENFANTS \OFF_SIZE
#define PRESSION_SELECTION 2
#define PRESSION_REPLACEMENT 2
#define NB_GENERATION \NB_GEN
//#define GPGPU




//INSERT_USER_FUNCTIONS
\INSERT_USER_FUNCTIONS
//INSERT_USER_DECLARATIONS
\INSERT_USER_DECLARATIONS
//INSERT_INITIALISATION_FUNCTION 
\INSERT_INITIALISATION_FUNCTION 

#include "onemax_cudaGenome.h"



//static inline size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
  size_t meilleurIndividu = 0;
  int meilleurFitness = 0;
  
  for( size_t i = 0 ; i<pression ; i++ ){
    size_t index = getRandomIntMax(popSize);
    if(population[index]->nFitness > meilleurFitness){
      meilleurFitness = population[index]->nFitness;
      meilleurIndividu = index;
    }
  }
  return meilleurIndividu;
}



CIndividu* selection(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_SELECTION);
  return population[meilleurIndividu];
}


CIndividu* remplacement(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_REPLACEMENT);
  CIndividu* selected = population[meilleurIndividu];
  //suppression de l'individu selectionne de la population courante
  population[meilleurIndividu] = population[popSize-1];
  return selected;
}


#define GPU_BUFFER_POS(buffer,index) (buffer+CIndividu::genomeSize()*index)


#ifdef GPGPU
void gpuEvaluation(char* parentGenomes,CIndividu** pPopParents,size_t popSize){
  OutputEa oeaNull;

  // compute fitness for all initial population on gpu
  float* results = launch_krnl(popSize,parentGenomes,0,&oeaNull);
  // write fitness in corresponding individuals
  for (size_t i=0;i<popSize;i++)
    pPopParents[i]->setFitness(results[i]);
  delete[] results;
}
#endif


int main(){
	
	
  /// declarations
	
  //FILE *fpFichierSauvegarde;
  CIndividu *tPop1[TAILLE_POP+TAILLE_POP_ENFANTS]; 
  CIndividu *tPop2[TAILLE_POP+TAILLE_POP_ENFANTS];
  CIndividu **pTemp;
	
  CIndividu **pPopCourante=(CIndividu **) tPop1;
  CIndividu **pNouvellePop=(CIndividu **) tPop2;
	
  CIndividu **pPopParents=pPopCourante; // Pointeur sur la population de parents
  CIndividu **pPopEnfants=&(pPopCourante[TAILLE_POP]); // Pointeur sur
  char* parentGenomes = (char*)malloc(CIndividu::genomeSize()*TAILLE_POP);
  char* offspringGenomes = (char*)malloc(CIndividu::genomeSize()*TAILLE_POP_ENFANTS);
  // la population
  // d'enfants
  float fPMut=0.05f;
  // l'ide'e est de  faire une mutation
  // par enfant cre'e' en moyenne, et donc
  // une probabilite' de mutation de
  // 1/nb_de_gènes
  float fPCross=1;  // Probabilite' d'appel du crossover
  int bElitisme=1;  // Pour commencer, on va utiliser de l'e'litisme
  int i,nNbEnfants=0,nTailleNouvellePop=0,nTaillePopCourante=0;
  //  int fIntensity =39 ; // pour l'instant c'est l'init defaut
  size_t generationCourante = 0;
	
	
	
  printf( "\n----> Cre'ation de la population : \n");
	
  // Cre'ation et initialisation de la population
  for (i=0;i<TAILLE_POP;i++) {
    pPopParents[i]=new CIndividu(GPU_BUFFER_POS(parentGenomes,i));
    printf("\npPopParents[%d]=%p\n",i,pPopParents[i]); 

  }

  
  for( i=TAILLE_POP; i<TAILLE_POP_ENFANTS ; i++)
    pPopEnfants[i] = NULL;
  
  for( i=0 ; i<TAILLE_POP+TAILLE_POP_ENFANTS; i++)
    pNouvellePop[i] = NULL;

  printf("\n----> Evaluation de la population \n");
	
  // Evaluation pour cre'er une population de parents

#ifdef GPGPU
  gpuEvaluation(parentGenomes,pPopParents,TAILLE_POP);
#else
  for (i=0;i<TAILLE_POP;i++)
    pPopParents[i]->evaluation();
 
#endif
  printf("\n\n");


  for (i=0;i<TAILLE_POP;i++)
    printf("%s\n",pPopParents[i]->toString().c_str());


  // Boucle e'volutionnaire
  while( generationCourante < NB_GENERATION ){
    printf("La PopParents contient :\n");
    for(i=0;i<TAILLE_POP;i++)
      printf("%p, ",pPopParents[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
		
    while (nNbEnfants<TAILLE_POP_ENFANTS){   // boucle sur la taille des enfants
			
      if (randomLoc(0,1)<fPCross) { // ope'rateur binaire (croisement) 
	printf("\nCroisement :\n");
				
	CIndividu *i1,*i2;
	i1=selection(pPopParents,TAILLE_POP);
				
	do{
	  i2=selection(pPopParents,TAILLE_POP);    // 
	} while (i2 ==i1); // Moui, c'est pas oblige' mais pourquoi pas...
	//rajouter un and afin de  stopper en cas de convergence
				
	if (randomLoc(0,1)<0.5) // micro-subtilite'... ;-)
	  pPopEnfants[nNbEnfants]=i1->croisement(i2,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));  
	else  
	  pPopEnfants[nNbEnfants]=i2->croisement(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
				
	printf("%p + %p = %p\n",i1,i2,pPopEnfants[nNbEnfants]);
				
      }
      else { // ope'rateur unaire (clonage)
	CIndividu *i1;
				
	i1=selection(pPopParents,TAILLE_POP);  //Il faut e'crire la se'lection
	pPopEnfants[nNbEnfants]=new CIndividu(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
	printf("Clonage: %p clone' en %p\n",i1,pPopEnfants[nNbEnfants]);
      }
			
      //printf("\nMutation de %p\n",pPopEnfants[nNbEnfants]);
			
      pPopEnfants[nNbEnfants]->mutation(fPMut,GPU_BUFFER_POS(offspringGenomes,nNbEnfants)); // mutation.
      nNbEnfants++;
    }
    // Bon, et bien on est maintenant au complet (parents + enfants)
    // Il faut maintenant e'valuer tous les enfants
		

    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");


#ifdef GPGPU
    gpuEvaluation(offspringGenomes,pPopEnfants,TAILLE_POP_ENFANTS);
#else
    for (i=0;i<TAILLE_POP_ENFANTS;i++)		
      pPopEnfants[i]->evaluation();
#endif
		
    printf("\n\n");
    // Il faut maintenant remplir la nouvelle population et on raisonne
    // maintenant en population globale parents+enfants
		
    nTaillePopCourante=TAILLE_POP+TAILLE_POP_ENFANTS;
    nTailleNouvellePop=0;
		
    printf("La PopCourante contient :\n");
    for(i=0;i<nTaillePopCourante;i++)
      printf("%p (%d), ",pPopParents[i],pPopParents[i]->nFitness);
    printf("\n");
		
    // Si on de'cide qu'il y a de l'e'litisme, on commence par un e'litisme mou
		
    if (bElitisme){
			
      int iMeilleur=0;
      for (i=1;i<nTaillePopCourante;i++)
	if (pPopCourante[i]->nFitness>pPopCourante[iMeilleur]->nFitness)
	  iMeilleur=i;
				
      pNouvellePop[0]=pPopCourante[iMeilleur];
				
      printf("----> Elitisme : on recopie %p dans la population d'enfants\n",pNouvellePop[0]);
				
      // Maintenant, on supprime de la population courante l'individu
      // qui a e'te' tranfe're' dans la nouvelle population
      pPopCourante[iMeilleur]=pPopCourante[nTaillePopCourante-1];
      nTaillePopCourante--; nTailleNouvellePop++;
    }
		
    printf("----> Remplacement\n");
    printf("----> Re'capitulatif avant Remplacement:\npPopCourante contient les individus :\n");
    for( i=0;i<nTaillePopCourante;i++)
      printf("%p, ",pPopCourante[i]);
		
    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]==NULL) printf("%p, ",pNouvellePop[i]);
			
    while(nTailleNouvellePop<TAILLE_POP){
      pNouvellePop[nTailleNouvellePop]=remplacement(pPopCourante,nTaillePopCourante);
				
      printf("\n\n%p est e'lu\n",pNouvellePop[nTailleNouvellePop]);
      nTaillePopCourante--; 
      nTailleNouvellePop++;
     
    }			

    printf("\n\n----> Re'capitulatif avant mise à jour :\npPopCourante contient les individus :\n");
    for(i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      printf("%p, ",pPopCourante[i]);
			
    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]==NULL) printf("%p, ",pNouvellePop[i]);
				
				
    //delete the contant of the current population, i.e. indiviudals that have not been selected by replacement
    for (int j=0;j<nTaillePopCourante;j++) {
      delete pPopCourante[j];
      pPopCourante[j] = NULL;
    }
				
    // Et maintenant, suprême astuce, on e'change les populations !
    // Go to the next population, swap populations
    pTemp=pPopCourante; pPopCourante=pPopParents=pNouvellePop;pNouvellePop=pTemp;
    pPopEnfants=&(pPopCourante[TAILLE_POP]);
				
    printf("PopCourante contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      printf("%p, ",pPopCourante[i]);
				
    printf("\npNouvellePop contient ... ce qu'elle contient:\n");
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]){
	printf("%p, ",pNouvellePop[i]);
      }
					
    printf("\n\n ON EST REPARTIS POUR UN TOUR !!! \n\n");
					
    // et on remet les compteurs à ze'ro
    nNbEnfants=0;
    generationCourante++;
  }


  for(size_t i = 0 ; i<TAILLE_POP ; i++){
    printf("%s\n", pPopCourante[i]->toString().c_str());
  }
  
  // free all internal structures
  for(size_t i = 0 ; i<TAILLE_POP ; i++) delete pPopCourante[i];
  
  free(offspringGenomes);
  free(parentGenomes);
    
  return 0;
}



\ANALYSE_PARAMETERS


\START_EO_GENOME_H_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAGenome.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

\ANALYSE_USER_CLASSES




#ifndef CINDIVIDU_HPP
#define CINDIVIDU_HPP

#define LG_GENOME 16
#include <stdlib.h>
//#include <iostream>
#include <sstream>
#include "tool.h"




class genome_t {
public:
  //INSERT_GENOME
  \INSERT_GENOME

  genome_t(){;}
  void copy(const genome_t& genome){
    \COPY_CTOR
  }
};


class CIndividu{
public:

  CIndividu(char* gpuBuffer);
  CIndividu(const CIndividu *, char* gpuBuffer);
  ~CIndividu();
  float evaluation();
  CIndividu* croisement(const CIndividu* i1,char* gpuBuffer)const;
  bool mutation(float, char* gpuBuffer);
  int nFitness; // a transformer en float 
  std::string toString();
  static size_t genomeSize(){ return sizeof(char)*LG_GENOME;}
  void setFitness(float f){ this->nFitness = f;}

private:
  genome_t genome;
};


void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize);
void showFitnessArray(float* fitnesses, size_t popSize);



CIndividu::CIndividu(char* gpuBuffer){
  //GENOME_CTOR
  \GENOME_CTOR
  \INSERT_INITIALISER
}


CIndividu::CIndividu(const CIndividu* ind, char* gpuBuffer){
   //INSERT_INITIALISER
  this->genome.copy(ind->genome);
}

CIndividu::~CIndividu(){
  //GENOME_DTOR
  \GENOME_DTOR
}

float CIndividu::evaluation(){
  //INSERT_EVALUATOR
  \INSERT_EVALUATOR
}

bool CIndividu::mutation(float fPMut, char* gpuBuffer){
  //INSERT_MUTATOR
  \INSERT_MUTATOR
}

CIndividu* CIndividu::croisement(const CIndividu* i1,char* gpuBuffer) const {
  CIndividu* child1 = new CIndividu(this,NULL);
  CIndividu* child2 = new CIndividu(i1,NULL);
  //INSERT_CROSSOVER
  \INSERT_CROSSOVER

    return child1;
}


std::string CIndividu::toString(){
  std::ostringstream cout;

  //INSERT_DISPLAY
  \INSERT_DISPLAY
  
  cout << " fitness : " << nFitness;
  cout << " addr : " << this;
  return cout.str();
}







// void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize){
//   size_t i,j;

//   for( i=0; i<popSize ; i++ ){
//     for( j=0 ; j<genSize ; j++){
//       printf( " %d |", population[i*genSize+j]);
//     }
//     printf( "\n");
//   }
// }


// void showFitnessArray(float* fitnesses, size_t popSize){
//   size_t i;

//   for(  i=0; i<popSize ; i++ ){
//     printf("Fitness of %d is %f\n", i, fitnesses[i]);
//   }
// }
#endif




\START_EO_EVAL_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAEvalFunc.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

/*
Evaluator in EO: a functor that computes the fitness of an EO
=============================================================
*/
 
#ifndef _EASEAEvalFunc_h
#define _EASEAEvalFunc_h

// include whatever general include you need
#include <stdexcept>
#include <fstream>

// include the base definition of eoEvalFunc
#include "eoEvalFunc.h"

/** 
  Always write a comment in this format before class definition
  if you want the class to be documented by Doxygen
*/
template <class EOT>
class EASEAEvalFunc : public eoEvalFunc<EOT>
{
public:
  /// Ctor - no requirement
// START eventually add or modify the anyVariable argument
  EASEAEvalFunc()
  //  EASEAEvalFunc( varType  _anyVariable) : anyVariable(_anyVariable) 
// END eventually add or modify the anyVariable argument
  {
    // START Code of Ctor of an EASEAEvalFunc object
    // END   Code of Ctor of an EASEAEvalFunc object
  }

  /** Actually compute the fitness
   *
   * @param EOT & _eo the EO object to evaluate
   *                  it should stay templatized to be usable 
   *                  with any fitness type
   */
  void operator()(EOT & genome)
  {
    // test for invalid to avoid recomputing fitness of unmodified individuals
    if (genome.invalid())
      {
    // START Code of computation of fitness of the EASEA object
\INSERT_EVALUATOR
    // END   Code of computation of fitness of the EASEA object
      }
  }

private:
// START Private data of an EASEAEvalFunc object
  //  varType anyVariable;       // for example ...
// END   Private data of an EASEAEvalFunc object
};


#endif

\START_EO_INITER_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAInit.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

/*
objects initialization in EO
============================
*/

#ifndef _EASEAInit_h
#define _EASEAInit_h

// include the base definition of eoInit
#include <eoInit.h>

/** 
 *  Always write a comment in this format before class definition
 *  if you want the class to be documented by Doxygen
 *
 * There is NO ASSUMPTION on the class GenoypeT.
 * In particular, it does not need to derive from EO (e.g. to initialize 
 *    atoms of an eoVector you will need an eoInit<AtomType>)
 */
template <class GenotypeT>
class EASEAInit: public eoInit<GenotypeT> {
public:
  /// Ctor - no requirement
// START eventually add or modify the anyVariable argument
  EASEAInit()
  //  EASEAInit( varType & _anyVariable) : anyVariable(_anyVariable) 
// END eventually add or modify the anyVariable argument
  {
    // START Code of Ctor of an EASEAInit object
    // END   Code of Ctor of an EASEAInit object
  }


  /** initialize a genotype
   *
   * @param _genotype  generally a genotype that has been default-constructed
   *                   whatever it contains will be lost
   */
  void operator()(GenotypeT & _genotype)
  {
    // START Code of random initialization of an EASEAGenome object
\INSERT_EO_INITIALISER
    // END   Code of random initialization of an EASEAGenome object
    _genotype.invalidate();    // IMPORTANT in case the _genotype is old
  }

private:
// START Private data of an EASEAInit object
  //  varType & anyVariable;       // for example ...
// END   Private data of an EASEAInit object
};

#endif


\START_EO_MUT_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAMutation.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

/*
simple mutation operators
=========================
*/

#ifndef EASEAMutation_H
#define EASEAMutation_H


#include <eoOp.h>

/** 
 *  Always write a comment in this format before class definition
 *  if you want the class to be documented by Doxygen
 *
 * THere is NO ASSUMPTION on the class GenoypeT.
 * In particular, it does not need to derive from EO
 */
template<class GenotypeT> 
class EASEAMutation: public eoMonOp<GenotypeT>
{
public:
  /**
   * Ctor - no requirement
   */
// START eventually add or modify the anyVariable argument
  EASEAMutation()
  //  EASEAMutation( varType  _anyVariable) : anyVariable(_anyVariable) 
// END eventually add or modify the anyVariable argument
  {
    // START Code of Ctor of an EASEAMutation object
    // END   Code of Ctor of an EASEAMutation object
  }

  /// The class name. Used to display statistics
  string className() const { return "EASEAMutation"; }

  /**
   * modifies the parent
   * @param _genotype The parent genotype (will be modified)
   */
  bool operator()(GenotypeT & _genotype) 
  {
    // START code for mutation of the _genotype object
\INSERT_MUTATOR
    // END code for mutation of the _genotype object

private:
// START Private data of an EASEAMutation object
  //  varType anyVariable;       // for example ...
// END   Private data of an EASEAMutation object
};

#endif

\START_EO_QUAD_XOVER_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAQuadCrossover.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

/*
Template for simple quadratic crossover operators
=================================================

Quadratic crossover operators modify both genotypes
*/

#ifndef EASEAQuadCrossover_H
#define EASEAQuadCrossover_H

#include <eoOp.h>

/** 
 *  Always write a comment in this format before class definition
 *  if you want the class to be documented by Doxygen
 *
 * THere is NO ASSUMPTION on the class GenoypeT.
 * In particular, it does not need to derive from EO
 */
template<class GenotypeT> 
class EASEAQuadCrossover: public eoQuadOp<GenotypeT>
{
public:
  /**
   * Ctor - no requirement
   */
// START eventually add or modify the anyVariable argument
  EASEAQuadCrossover()
  //  EASEAQuadCrossover( varType  _anyVariable) : anyVariable(_anyVariable) 
// END eventually add or modify the anyVariable argument
  {
    // START Code of Ctor of an EASEAQuadCrossover object
    // END   Code of Ctor of an EASEAQuadCrossover object
  }

  /// The class name. Used to display statistics
  string className() const { return "EASEAQuadCrossover"; }

  /**
   * eoQuad crossover - modifies both genotypes
   */
  bool operator()(GenotypeT& child1, GenotypeT & child2) 
  {
      GenotypeT parent1(child1);
      GenotypeT parent2(child2);
    
    // START code for crossover of child1 and child2 objects
\INSERT_CROSSOVER
    return (parent1!=child1)||(parent2!=child2);
    // END code for crossover of child1 and child2 objects
  }

private:
// START Private data of an EASEAQuadCrossover object
  //  varType anyVariable;       // for example ...
// END   Private data of an EASEAQuadCrossover object
};

#endif

\START_EO_CONTINUE_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEA_make_continue.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

#ifndef _make_continue_h
#define _make_continue_h

/*
Contains the templatized version of parser-based choice of stopping criterion
It can then be instantiated, and compiled on its own for a given EOType
(see e.g. in dir ga, ga.cpp)
*/

// Continuators - all include eoContinue.h
#include <eoCombinedContinue.h>
#include <eoGenContinue.h>
#include <eoSteadyFitContinue.h>
#include <eoEvalContinue.h>
#include <eoFitContinue.h>
#ifndef _MSC_VER
#include <eoCtrlCContinue.h>  // CtrlC handling (using 2 global variables!)
#endif

  // also need the parser and param includes
#include <utils/eoParser.h>
#include <utils/eoState.h>


/////////////////// the stopping criterion ////////////////
template <class Indi>
eoCombinedContinue<Indi> * make_combinedContinue(eoCombinedContinue<Indi> *_combined, eoContinue<Indi> *_cont)
{
  if (_combined)       // already exists
    _combined->add(*_cont);
  else
    _combined = new eoCombinedContinue<Indi>(*_cont);
  return _combined;
}

template <class Indi>
eoContinue<Indi> & do_make_continue(eoParser& _parser, eoState& _state, eoEvalFuncCounter<Indi> & _eval)
{
  //////////// Stopping criterion ///////////////////
  // the combined continue - to be filled
  eoCombinedContinue<Indi> *continuator = NULL;

  // for each possible criterion, check if wanted, otherwise do nothing

  // First the eoGenContinue - need a default value so you can run blind
  // but we also need to be able to avoid it <--> 0
  eoValueParam<unsigned>& maxGenParam = _parser.createParam(\NB_GEN, "maxGen", "Maximum number of generations () = none)",'G',"Stopping criterion");
  // and give control to EASEA
    EZ_NB_GEN = maxGenParam.value();
    pEZ_NB_GEN = & maxGenParam.value();

    // do not test for positivity in EASEA
    //    if (maxGenParam.value()) // positive: -> define and store
    //      {
  eoGenContinue<Indi> *genCont = new eoGenContinue<Indi>(maxGenParam.value());
  _state.storeFunctor(genCont);
  // and "add" to combined
  continuator = make_combinedContinue<Indi>(continuator, genCont);
  //      }

  // the steadyGen continue - only if user imput
  eoValueParam<unsigned>& steadyGenParam = _parser.createParam(unsigned(100), "steadyGen", "Number of generations with no improvement",'s', "Stopping criterion");
  eoValueParam<unsigned>& minGenParam = _parser.createParam(unsigned(0), "minGen", "Minimum number of generations",'g', "Stopping criterion");
    if (_parser.isItThere(steadyGenParam))
      {
  eoSteadyFitContinue<Indi> *steadyCont = new eoSteadyFitContinue<Indi>
    (minGenParam.value(), steadyGenParam.value());
  // store
  _state.storeFunctor(steadyCont);
  // add to combinedContinue
  continuator = make_combinedContinue<Indi>(continuator, steadyCont);
      }

  // Same thing with Eval - but here default value is 0
  eoValueParam<unsigned long>& maxEvalParam = _parser.createParam((unsigned long)0, "maxEval", "Maximum number of evaluations (0 = none)",'E',"Stopping criterion");

    if (maxEvalParam.value()) // positive: -> define and store
      {
  eoEvalContinue<Indi> *evalCont = new eoEvalContinue<Indi>(_eval, maxEvalParam.value());
  _state.storeFunctor(evalCont);
  // and "add" to combined
  continuator = make_combinedContinue<Indi>(continuator, evalCont);
      }
    /*
  // the steadyEval continue - only if user imput
  eoValueParam<unsigned>& steadyGenParam = _parser.createParam(unsigned(100), "steadyGen", "Number of generations with no improvement",'s', "Stopping criterion");
  eoValueParam<unsigned>& minGenParam = _parser.createParam(unsigned(0), "minGen", "Minimum number of generations",'g', "Stopping criterion");
    if (_parser.isItThere(steadyGenParam))
      {
  eoSteadyGenContinue<Indi> *steadyCont = new eoSteadyFitContinue<Indi>
    (minGenParam.value(), steadyGenParam.value());
  // store
  _state.storeFunctor(steadyCont);
  // add to combinedContinue
  continuator = make_combinedContinue<Indi>(continuator, steadyCont);
      }
    */
    // the target fitness
    eoFitContinue<Indi> *fitCont;
    eoValueParam<double>& targetFitnessParam = _parser.createParam(double(0.0), "targetFitness", "Stop when fitness reaches",'T', "Stopping criterion");
    if (_parser.isItThere(targetFitnessParam))
      {
  fitCont = new eoFitContinue<Indi>
    (targetFitnessParam.value());
  // store
  _state.storeFunctor(fitCont);
  // add to combinedContinue
  continuator = make_combinedContinue<Indi>(continuator, fitCont);
      }

#ifndef _MSC_VER
    // the CtrlC interception (Linux only I'm afraid)
    eoCtrlCContinue<Indi> *ctrlCCont;
    eoValueParam<bool>& ctrlCParam = _parser.createParam(false, "CtrlC", "Terminate current generation upon Ctrl C",'C', "Stopping criterion");
    if (_parser.isItThere(ctrlCParam))
      {
  ctrlCCont = new eoCtrlCContinue<Indi>;
  // store
  _state.storeFunctor(ctrlCCont);
  // add to combinedContinue
  continuator = make_combinedContinue<Indi>(continuator, ctrlCCont);
      }
#endif

    // now check that there is at least one!
    if (!continuator)
      throw runtime_error("You MUST provide a stopping criterion");
  // OK, it's there: store in the eoState
  _state.storeFunctor(continuator);

  // and return
    return *continuator;
}

#endif

\START_EO_PARAM_TPL#****************************************
#                                         
#  EASEA.prm
#                                         
#  Parameter file generated by AESAE-EO v0.7b
#                                         
#****************************************
######    General    ######
# --help=0 # -h : Prints this message
# --stopOnUnknownParam=1 # Stop if unknown param entered
--seed=S   # -S : Random number seed. It is possible to give a specific seed.

######    Evolution Engine    ######
--popSize=\POP_SIZE # -P : Population Size
--selection=\SELECTOR\SELECT_PRM # -S : Selection: Roulette, Ranking(p,e), DetTour(T), StochTour(t) or Sequential(ordered/unordered)
--nbOffspring=\OFF_SIZE # -O : Nb of offspring (percentage or absolute)
--replacement=General # Type of replacement: Generational, ESComma, ESPlus, SSGA(T), EP(T)

######    Evolution Engine / Replacement    ######
--elite=\ELITE_SIZE  # Nb of elite parents (percentage or absolute)
--eliteType=\ELITISM # Strong (true) or weak (false) elitism (set elite to 0 for none)
--surviveParents=\SURV_PAR_SIZE # Nb of surviving parents (percentage or absolute)
--reduceParents=\RED_PAR\RED_PAR_PRM # Parents reducer: Deterministic, EP(T), DetTour(T), StochTour(t), Uniform
--surviveOffspring=\SURV_OFF_SIZE  # Nb of surviving offspring (percentage or absolute)
--reduceOffspring=\RED_OFF\RED_OFF_PRM # Offspring reducer: Deterministic, EP(T), DetTour(T), StochTour(t), Uniform
--reduceFinal=\RED_FINAL\RED_FINAL_PRM # Final reducer: Deterministic, EP(T), DetTour(T), StochTour(t), Uniform

######    Output    ######
# --useEval=1 # Use nb of eval. as counter (vs nb of gen.)
# --useTime=1 # Display time (s) every generation
# --printBestStat=1 # Print Best/avg/stdev every gen.
# --printPop=0 # Print sorted pop. every gen.

######    Output - Disk    ######
# --resDir=Res # Directory to store DISK outputs
# --eraseDir=1 # erase files in dirName if any
# --fileBestStat=0 # Output bes/avg/std to file

######    Output - Graphical    ######
--plotBestStat=1 # Plot Best/avg Stat
--plotHisto=1 # Plot histogram of fitnesses

######    Persistence    ######
# --Load= # -L : A save file to restart from
# --recomputeFitness=0 # -r : Recompute the fitness after re-loading the pop.?
# --saveFrequency=0 # Save every F generation (0 = only final state, absent = never)
# --saveTimeInterval=0 # Save every T seconds (0 or absent = never)
# --status=OneMaxGenomeEA.status # Status file

######    Stopping criterion    ######
--maxGen=\NB_GEN # -G : Maximum number of generations () = none)
# --steadyGen=100 # -s : Number of generations with no improvement
# --minGen=0 # -g : Minimum number of generations
# --maxEval=0 # -E : Maximum number of evaluations (0 = none)
# --targetFitness=0 # -T : Stop when fitness reaches
# --CtrlC=0 # -C : Terminate current generation upon Ctrl C

######    Variation Operators    ######
# --cross1Rate=1 # -1 : Relative rate for crossover 1
# --mut1Rate=1 # -1 : Relative rate for mutation 1
--pCross=\XOVER_PROB # -C : Probability of Crossover
--pMut=\MUT_PROB # -M : Probability of Mutation

\START_EO_MAKEFILE_TPL#****************************************
#                                         
#  EASEA.mak
#                                         
#  Makefile generated by AESAE-EO v0.7b
#                                         
#****************************************

# sample makefile for building an EA evolving a new genotype

DIR_EO = \EO_DIR

.cpp: ; c++  -DPACKAGE=\"eo\" -I. -I$(DIR_EO)/src -Wall -g  -o $@  $*.cpp $(DIR_EO)/src/libeo.a $(DIR_EO)/src/utils/libeoutils.a

.cpp.o: ; c++ -DPACKAGE=\"eo\" -I. -I\EO_DIR/src -Wall -g -c $*.cpp

LIB_EO = $(DIR_EO)/src/utils/libeoutils.a $(DIR_EO)/src/libeo.a

SOURCES = EASEA.cpp \
  EASEAEvalFunc.h \
  EASEAGenome.h \
  EASEAInit.h \
  EASEAMutation.h \
  EASEAQuadCrossover.h \
  $(LIB_EO)

ALL = EASEA EASEA.opt

EASEA : $(SOURCES)
	c++ -g -I. -I$(DIR_EO)/src -o $@ EASEA.cpp $(LIB_EO) -lm -Wno-deprecated 

EASEA.opt : $(SOURCES)
	c++ -O4 -I. -I$(DIR_EO)/src -o $@ EASEA.cpp $(LIB_EO) -lm -Wno-deprecated 

all : $(ALL)

clean : ; /bin/rm  *.o $(ALL)

\TEMPLATE_END
