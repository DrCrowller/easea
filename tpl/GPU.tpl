\TEMPLATE_START// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEA.cpp
//                                         
//  C++ file generated by AESAE-CUDA v0.9a
//                                         
//****************************************


\ANALYSE_PARAMETERS
#include <unistd.h>
#include "tool/outputea.h"
#include <stdio.h>
#include "tool/tool.h"

#define TAILLE_POP \POP_SIZE
#define TAILLE_POP_ENFANTS \OFF_SIZE
#define PRESSION_SELECTION 2
#define PRESSION_REPLACEMENT 2
#define NB_GENERATION \NB_GEN
#define GPGPU
#include "EASEAIndividual.h"  //Generated individual
#include "EASEAGPUEval.h"     //Generated header for gpu evaluation
#include "EASEAUserFunc.h"

//INSERT_INITIALISATION_FUNCTION 
\INSERT_INITIALISATION_FUNCTION 



//static inline size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
size_t tournoi(CIndividu** population, size_t popSize, size_t pression){
  size_t meilleurIndividu = 0;
  float meilleurFitness = 0;
  
  for( size_t i = 0 ; i<pression ; i++ ){
    size_t index = getRandomIntMax(popSize);
    if(population[index]->nFitness > meilleurFitness){
      meilleurFitness = population[index]->nFitness;
      meilleurIndividu = index;
    }
  }
  return meilleurIndividu;
}



CIndividu* selection(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_SELECTION);
  return population[meilleurIndividu];
}


CIndividu* remplacement(CIndividu** population, size_t popSize){
  size_t meilleurIndividu = tournoi(population,popSize,PRESSION_REPLACEMENT);
  CIndividu* selected = population[meilleurIndividu];
  //suppression de l'individu selectionne de la population courante
  population[meilleurIndividu] = population[popSize-1];
  return selected;
}


#define GPU_BUFFER_POS(buffer,index) (buffer+sizeof(genome_t)*index)


#ifdef GPGPU
void gpuEvaluation(char* parentGenomes,CIndividu** pPopParents,size_t popSize){
  OutputEa oeaNull;

  // compute fitness for all initial population on gpu
  float* results = launch_krnl(popSize,parentGenomes);
  // write fitness in corresponding individuals
  for (size_t i=0;i<popSize;i++){
    printf("%p %f\n",pPopParents[i],results[i]);
    pPopParents[i]->setFitness(results[i]);
  }
  delete[] results;
}
#endif


int main(){
	
	
  /// declarations
	
  //FILE *fpFichierSauvegarde;
  CIndividu *tPop1[TAILLE_POP+TAILLE_POP_ENFANTS]; 
  CIndividu *tPop2[TAILLE_POP+TAILLE_POP_ENFANTS];
  CIndividu **pTemp;
	
  CIndividu **pPopCourante=(CIndividu **) tPop1;
  CIndividu **pNouvellePop=(CIndividu **) tPop2;
	
  CIndividu **pPopParents=pPopCourante; // Pointeur sur la population de parents
  CIndividu **pPopEnfants=&(pPopCourante[TAILLE_POP]); // Pointeur sur
  char* parentGenomes = (char*)malloc(sizeof(genome_t)*TAILLE_POP);
  char* offspringGenomes = (char*)malloc(sizeof(genome_t)*TAILLE_POP_ENFANTS);
  // la population
  // d'enfants
  float fPMut=0.05f;
  // l'ide'e est de  faire une mutation
  // par enfant cre'e' en moyenne, et donc
  // une probabilite' de mutation de
  // 1/nb_de_gènes
  float fPCross=1;  // Probabilite' d'appel du crossover
  int bElitisme=1;  // Pour commencer, on va utiliser de l'e'litisme
  int i,nNbEnfants=0,nTailleNouvellePop=0,nTaillePopCourante=0;
  //  int fIntensity =39 ; // pour l'instant c'est l'init defaut
  size_t generationCourante = 0;
	
  showInfo();
	
  printf( "\n----> Cre'ation de la population : \n");
	
  // Cre'ation et initialisation de la population
  for (i=0;i<TAILLE_POP;i++) {
    pPopParents[i]=new CIndividu(GPU_BUFFER_POS(parentGenomes,i));
    printf("\npPopParents[%d]=%p\n",i,pPopParents[i]); 

  }

  
  for( i=TAILLE_POP; i<TAILLE_POP_ENFANTS ; i++)
    pPopEnfants[i] = NULL;
  
  for( i=0 ; i<TAILLE_POP+TAILLE_POP_ENFANTS; i++)
    pNouvellePop[i] = NULL;

  printf("\n----> Evaluation de la population \n");
	
  // Evaluation pour cre'er une population de parents

#ifdef GPGPU
  gpuEvaluation(parentGenomes,pPopParents,TAILLE_POP);
  showPopulationBooleanArray(parentGenomes,SIZE,TAILLE_POP);
#else
  for (i=0;i<TAILLE_POP;i++)
    pPopParents[i]->evaluation();
 
#endif
  printf("\n\n");
  //exit(-1);

  for (i=0;i<TAILLE_POP;i++)
    printf("%s\n",pPopParents[i]->toString().c_str());


  // Boucle e'volutionnaire
  while( generationCourante < NB_GENERATION ){
    printf("La PopParents contient :\n");
    for(i=0;i<TAILLE_POP;i++)
      printf("%p, ",pPopParents[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");
		
    while (nNbEnfants<TAILLE_POP_ENFANTS){   // boucle sur la taille des enfants
			
      if (randomLoc(0,1)<fPCross) { // ope'rateur binaire (croisement) 
	printf("\nCroisement :\n");
				
	CIndividu *i1,*i2;
	i1=selection(pPopParents,TAILLE_POP);
				
	do{
	  i2=selection(pPopParents,TAILLE_POP);    // 
	} while (i2 ==i1); // Moui, c'est pas oblige' mais pourquoi pas...
	//rajouter un and afin de  stopper en cas de convergence
				
	if (randomLoc(0,1)<0.5) // micro-subtilite'... ;-)
	  pPopEnfants[nNbEnfants]=i1->croisement(i2,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));  
	else  
	  pPopEnfants[nNbEnfants]=i2->croisement(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
				
	printf("%p + %p = %p\n",i1,i2,pPopEnfants[nNbEnfants]);
	
      }
      else { // ope'rateur unaire (clonage)
	CIndividu *i1;
				
	i1=selection(pPopParents,TAILLE_POP);  //Il faut e'crire la se'lection
	pPopEnfants[nNbEnfants]=new CIndividu(i1,GPU_BUFFER_POS(offspringGenomes,nNbEnfants));
	printf("Clonage: %p clone' en %p\n",i1,pPopEnfants[nNbEnfants]);
      }
      
      //printf("\nMutation de %p\n",pPopEnfants[nNbEnfants]);
      
      pPopEnfants[nNbEnfants]->mutation(fPMut,GPU_BUFFER_POS(offspringGenomes,nNbEnfants)); // mutation.
      memcpy(GPU_BUFFER_POS(offspringGenomes,nNbEnfants),&(pPopEnfants[nNbEnfants]->genome),sizeof(genome_t));

      nNbEnfants++;
    }
    // Bon, et bien on est maintenant au complet (parents + enfants)
    // Il faut maintenant e'valuer tous les enfants
		

    printf("\n");
    printf("-----------------------------------------------------------------");
    printf("\n");


#ifdef GPGPU
    gpuEvaluation(offspringGenomes,pPopEnfants,TAILLE_POP_ENFANTS);
#else
    for (i=0;i<TAILLE_POP_ENFANTS;i++)		
      pPopEnfants[i]->evaluation();
#endif


    for (i=0;i<TAILLE_POP;i++)
      printf("%s\n",pPopEnfants[i]->toString().c_str());
      
		
    printf("\n\n");
    // Il faut maintenant remplir la nouvelle population et on raisonne
    // maintenant en population globale parents+enfants
		
    nTaillePopCourante=TAILLE_POP+TAILLE_POP_ENFANTS;
    nTailleNouvellePop=0;
		
    printf("La PopCourante contient :\n");
    for(i=0;i<nTaillePopCourante;i++)
      printf("%p (%d), ",pPopParents[i],pPopParents[i]->nFitness);
    printf("\n");
		
    // Si on de'cide qu'il y a de l'e'litisme, on commence par un e'litisme mou
		
    if (bElitisme){
			
      int iMeilleur=0;
      for (i=1;i<nTaillePopCourante;i++)
	if (pPopCourante[i]->nFitness>pPopCourante[iMeilleur]->nFitness)
	  iMeilleur=i;
				
      pNouvellePop[0]=pPopCourante[iMeilleur];
				
      printf("----> Elitisme : on recopie %p dans la population d'enfants\n",pNouvellePop[0]);
				
      // Maintenant, on supprime de la population courante l'individu
      // qui a e'te' tranfe're' dans la nouvelle population
      pPopCourante[iMeilleur]=pPopCourante[nTaillePopCourante-1];
      nTaillePopCourante--; nTailleNouvellePop++;
    }
		
    printf("----> Remplacement\n");
    printf("----> Re'capitulatif avant Remplacement:\npPopCourante contient les individus :\n");
    for( i=0;i<nTaillePopCourante;i++)
      printf("%p, ",pPopCourante[i]);
		
    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]==NULL) printf("%p, ",pNouvellePop[i]);
			
    while(nTailleNouvellePop<TAILLE_POP){
      pNouvellePop[nTailleNouvellePop]=remplacement(pPopCourante,nTaillePopCourante);
				
      printf("\n\n%p est e'lu\n",pNouvellePop[nTailleNouvellePop]);
      nTaillePopCourante--; 
      nTailleNouvellePop++;
     
    }			

    printf("\n\n----> Re'capitulatif avant mise à jour :\npPopCourante contient les individus :\n");
    for(i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      printf("%p, ",pPopCourante[i]);
			
    printf("\npNouvellePop contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]==NULL) printf("%p, ",pNouvellePop[i]);
				
				
    //delete the contant of the current population, i.e. indiviudals that have not been selected by replacement
    for (int j=0;j<nTaillePopCourante;j++) {
      delete pPopCourante[j];
      pPopCourante[j] = NULL;
    }
				
    // Et maintenant, suprême astuce, on e'change les populations !
    // Go to the next population, swap populations
    pTemp=pPopCourante; pPopCourante=pPopParents=pNouvellePop;pNouvellePop=pTemp;
    pPopEnfants=&(pPopCourante[TAILLE_POP]);
				
    printf("PopCourante contient les individus (dont les %d premiers sont bons) :\n",nTailleNouvellePop);
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      printf("%p, ",pPopCourante[i]);
				
    printf("\npNouvellePop contient ... ce qu'elle contient:\n");
    for( i=0;i<TAILLE_POP+TAILLE_POP_ENFANTS;i++)
      if (pNouvellePop[i]){
	printf("%p, ",pNouvellePop[i]);
      }
					
    printf("\n\n ON EST REPARTIS POUR UN TOUR !!! \n\n");
					
    // et on remet les compteurs à ze'ro
    nNbEnfants=0;
    generationCourante++;
  }


  for(size_t i = 0 ; i<TAILLE_POP ; i++){
    printf("%s\n", pPopCourante[i]->toString().c_str());
  }
  
  // free all internal structures
  for(size_t i = 0 ; i<TAILLE_POP ; i++) delete pPopCourante[i];
  
  free(offspringGenomes);
  free(parentGenomes);
    
  return 0;
}



\ANALYSE_PARAMETERS


\START_USER_FUN_H_TPL
#ifndef USER_FUNC
#define USER_FUNC
//INSERT_USER_FUNCTIONS
\INSERT_USER_FUNCTIONS
//INSERT_USER_DECLARATIONS
\INSERT_USER_DECLARATIONS
#endif



\START_GPU_INDIVIDUAL_H_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
//
// (The above line is useful in Emacs-like editors)
//
//****************************************
//                                         
//  EASEAGenome.h
//                                         
//  C++ file generated by AESAE-EO v0.7b
//                                         
//****************************************
//

\ANALYSE_USER_CLASSES
#ifndef CINDIVIDU_HPP
#define CINDIVIDU_HPP

#define LG_GENOME 16
#include <stdlib.h>
//#include <iostream>
#include <sstream>
#include "tool/tool.h"
#include "EASEAUserFunc.h"






class genome_t {
public:
  //INSERT_GENOME
  \INSERT_GENOME

  genome_t(){;}
  void copy(const genome_t& genome){
    \COPY_CTOR
  }
};


class CIndividu{
public:

  CIndividu(char* gpuBuffer);
  CIndividu(const CIndividu *, char* gpuBuffer);
  ~CIndividu();
  float evaluation();
  CIndividu* croisement(const CIndividu* i1,char* gpuBuffer)const;
  bool mutation(float, char* gpuBuffer);
  float nFitness; // a transformer en float 
  std::string toString();
  static size_t genomeSize(){ return sizeof(char)*LG_GENOME;}
  void setFitness(float f){ this->nFitness = f;}

  genome_t genome;
};


void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize);
void showFitnessArray(float* fitnesses, size_t popSize);

#endif
\START_GPU_INDIVIDUAL_CPP_TPL// -*- mode: c++; c-indent-level: 2; c++-member-init-indent: 8; comment-column: 35; -*-
#include "EASEAIndividual.h"

CIndividu::CIndividu(char* gpuBuffer){
  //GENOME_CTOR
  \GENOME_CTOR
  \INSERT_INITIALISER
    ;

  //copy the current genome in the gpuBuffer
  memcpy(gpuBuffer,&(this->genome),sizeof(genome_t));
}


CIndividu::CIndividu(const CIndividu* ind, char* gpuBuffer){
  
   //INSERT_INITIALISER
  this->genome.copy(ind->genome);
  if(gpuBuffer) memcpy(gpuBuffer,&(this->genome),sizeof(genome_t));
}

CIndividu::~CIndividu(){
  //GENOME_DTOR
  \GENOME_DTOR
}

float CIndividu::evaluation(){
  //INSERT_EVALUATOR
  \INSERT_EVALUATOR
}

bool CIndividu::mutation(float fPMut, char* gpuBuffer){
  //INSERT_MUTATOR
  \INSERT_MUTATOR
}

CIndividu* CIndividu::croisement(const CIndividu* i1,char* gpuBuffer) const {
  CIndividu* child1 = new CIndividu(this,NULL);
  CIndividu* child2 = new CIndividu(i1,NULL);
  //INSERT_CROSSOVER
  \INSERT_CROSSOVER
    ;
  memcpy(gpuBuffer,&(child1->genome),sizeof(genome_t));
  free(child2);
  return child1;
}


std::string CIndividu::toString(){
  std::ostringstream cout;

  //INSERT_DISPLAY
  \INSERT_DISPLAY
  
  cout << " fitness : " << nFitness;
  cout << " addr : " << this;
  return cout.str();
}


void showPopulationBooleanArray(char* population,size_t genSize, size_t popSize){
  size_t i,j;

  for( i=0; i<popSize ; i++ ){
    for( j=0 ; j<genSize ; j++){
      printf( " %d |", population[i*genSize+j]);
    }
    printf( "\n");
  }
}


void showFitnessArray(float* fitnesses, size_t popSize){
  size_t i;

  for(  i=0; i<popSize ; i++ ){
    printf("Fitness of %d is %f\n", i, fitnesses[i]);
  }
}




\START_GPU_EVAL_H_TPL
//START_GPU_EVAL_H_TPL
#ifndef GPU_EVA_H_TPL
#define GPU_EVA_H_TPL

float* 
launch_krnl(size_t popSize, BOOLEAN_EA* pop);
void showInfo(void);

#endif

\START_GPU_EVAL_CU_TPL
//START_GPU_EVAL_CU_TPL
#define DEBUG_KRNL
#include "tool/basetype.h"
#include "tool/tool.h"
#include "tool/timing.h"
#include "tool/debug.h"
#include "EASEAUserFunc.h"
#include "EASEAIndividual.h"
#include <iostream>
#include <assert.h>


using namespace std;



#define MAX_THREAD_NUM 512
#define NB_MP 8



#define NB_MP 8
#define MAX_BLOCK_SIZE 512


bool
repartition(size_t popSize, size_t* nbBlock, size_t* nbThreadPB, size_t* nbThreadLB, 
	    size_t nbMP, size_t maxBlockSize){
  
  (*nbThreadLB) = 0;
  
  if( ((float)popSize / (float)nbMP) <= maxBlockSize ){
    //la population répartie sur les MP tient dans une bloc par MP
    (*nbThreadPB) = partieEntiereSup( (float)popSize/(float)nbMP);
    (*nbBlock) = popSize/(*nbThreadPB);
    if( popSize%nbMP != 0 ){
      //on fait MP-1 block de équivalent et un plus petit
      (*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
    }
  }
  else{
    //la population est trop grande pour etre répartie sur les MP
    //directement
    (*nbBlock) = partieEntiereSup( (float)popSize/((float)maxBlockSize*8));
    (*nbBlock) *=8;
    (*nbThreadPB) = popSize/(*nbBlock);
    if( popSize%maxBlockSize!=0){
      (*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
      
      // Le rest est trop grand pour etre placé dans un seul block (c'est possible uniquement qd 
      // le nombre de block dépasse maxBlockSize 
      while( (*nbThreadLB) > maxBlockSize ){
	//on augmente le nombre de blocs principaux jusqu'à ce que nbthreadLB retombe en dessous de maxBlockSize
	(*nbBlock) += nbMP;
 	(*nbThreadPB) = popSize/(*nbBlock);
	(*nbThreadLB) = popSize - (*nbThreadPB)*(*nbBlock);
      }
    }
  }
  
  if((((*nbBlock)*(*nbThreadPB) + (*nbThreadLB))  == popSize) 
     && ((*nbThreadLB) <= maxBlockSize) && ((*nbThreadPB) <= maxBlockSize))
    return true;
  else 
    return false;
}




__host__ void showInfo(){
  int devCount,i;
  cudaError_t lastError;
  struct cudaDeviceProp cdp;
  
  CDC(lastError,"cudaGetDeviceCount",cudaGetDeviceCount(&devCount));
  
  printf("Number of device : %d\n",devCount);
  for( i=0 ; i<devCount ; i++ ){
    CDC(lastError,"cudaGetDeviceProperties",cudaGetDeviceProperties(&cdp,i));
    printf("Name : %s\n",cdp.name);
    printf("TotalGlobalMem %d\n",cdp.totalGlobalMem);
    printf("SharedMemPerBlock %d\n",cdp.sharedMemPerBlock);
    printf("regsPerBlock %d\n",cdp.regsPerBlock);
    printf("warpSize %d\n",cdp.warpSize);
    printf("memPitch %d\n",cdp.memPitch);
    printf("maxThreadsPerBlock %d\n",cdp.maxThreadsPerBlock);
    
    printf("maxThreadsDim.x %d\n",cdp.maxThreadsDim[0]);
    printf("maxThreadsDim.y %d\n",cdp.maxThreadsDim[1]);
    printf("maxThreadsDim.z %d\n",cdp.maxThreadsDim[2]);
    
    printf("maxGridSize.x %d\n",cdp.maxGridSize[0]);
    printf("maxGridSize.y %d\n",cdp.maxGridSize[1]);
    printf("maxGridSize.z %d\n",cdp.maxGridSize[2]);
    
    printf("totalConstMem %d\n",cdp.totalConstMem);
    printf("major %d\n",cdp.major);
    printf("minor %d\n",cdp.minor);
    printf("clockRate %d\n",cdp.clockRate);
    printf("textureAlignment %d\n",cdp.textureAlignment);
    printf("deviceOverlap %d\n",cdp.deviceOverlap);
    printf("multiProcessorCount %d\n",cdp.multiProcessorCount);
  }
}


__host__ __device__ FITNESS_TYPE gpuEvaluate(BOOLEAN_EA* rawGenome){


  genome_t* genome = (genome_t*)rawGenome;

  //INSERT_EVALUATOR
  \INSERT_EVALUATOR
}


__global__ void cudaEvaluatePopulationSM(BOOLEAN_EA* d_population, float* d_fitnesses, size_t nbThreadLB){

  extern __shared__ BOOLEAN_EA s_data[];
  size_t id = blockDim.x*blockIdx.x+threadIdx.x;    
  size_t individual = id*sizeof(genome_t);
  size_t i=0;


  // last block is the block which computes reminder
  if( blockIdx.x == gridDim.x-1){
    if( threadIdx.x >= nbThreadLB ) return;
  }

  //do the copy in the shared memory
  for(i=0;i<sizeof(genome_t);i++) s_data[(threadIdx.x*sizeof(genome_t))+i] = d_population[individual+i];
  
  
  d_fitnesses[id] = gpuEvaluate(s_data+(threadIdx.x*sizeof(genome_t)));

}




__global__ void cudaEvaluatePopulation(BOOLEAN_EA* d_population, float* d_fitnesses, size_t nbThreadLB){


  size_t individual = blockDim.x*blockIdx.x*sizeof(genome_t)+threadIdx.x*sizeof(genome_t);
  size_t id = blockDim.x*blockIdx.x+threadIdx.x;
  size_t i=0;

  // last block is the block which computes reminder
  if( blockIdx.x == gridDim.x-1){
    if( threadIdx.x >= nbThreadLB ) return;
  }
  
  d_fitnesses[id] = 0;
  //real computation
  for( i=0 ; i<sizeof(genome_t) ; i++ )
    if(d_population[individual+i])
      d_fitnesses[id] += 1;
}



float* 
launch_krnl(size_t popSize, BOOLEAN_EA* pop){
  BOOLEAN_EA* d_population;
  float* fitnessTab, * d_fitnessTab;
  cudaError_t lastError = cudaSuccess;

  size_t nbBlock,nbThreadPB,nbThreadLB;
  size_t memSize = sizeof(genome_t) * popSize;
  fitnessTab = new float[popSize];

  CDC(lastError,"CudaMalloc d_population",cudaMalloc( (void**) &d_population, memSize));
  CDC(lastError,"CudaMalloc d_fitnessTab",cudaMalloc( (void**) &d_fitnessTab, popSize*sizeof(float)));
  
  

  CDC(lastError,"CudaMemCpy #1",cudaMemcpy( d_population, pop, memSize, cudaMemcpyHostToDevice));
  //cudaThreadSynchronize();
  
  //compute the repartition over MP and SP
  repartition(popSize,&nbBlock,&nbThreadPB,&nbThreadLB,NB_MP,MAX_THREAD_NUM);
  dim3 dimBlock(nbThreadPB);
  dim3 dimGrid;

  size_t sharedMemSize = nbThreadPB*sizeof(genome_t)*sizeof(BOOLEAN_EA);

  
  cout << "repartition -> nbBlock : " << nbBlock << " nbThreadPB : " << nbThreadPB
       << " nbThreadLB : " << nbThreadLB << endl;

  cout << "Shared memory usage : " << sharedMemSize << endl;

  //wird things, take a look. Does the bug of repartition function become from here?
  if( nbThreadLB == 0 )
    dimGrid = dim3(nbBlock+1);
  else
    dimGrid = dim3(nbBlock+1);


  CDC(
      lastError,
      "Launch kernel",
      (cudaEvaluatePopulationSM<<< dimGrid, dimBlock , sharedMemSize >>>(d_population,d_fitnessTab,nbThreadLB)));
  cudaThreadSynchronize();
  
  CDC(lastError,"CudaMemCpy #2",cudaMemcpy( fitnessTab , d_fitnessTab , popSize*sizeof(float), cudaMemcpyDeviceToHost));

  CDC(lastError,"CudaFree d_population",cudaFree( (void*) d_population));
  CDC(lastError,"CudaFree d_fitnessTab",cudaFree( (void*) d_fitnessTab));

  return fitnessTab;
}

//START_EO_INITER_TPL
//START_EO_MUT_TPL
//START_EO_QUAD_XOVER_TPL
//START_EO_CONTINUE_TPL
//START_EO_PARAM_TPL
\START_EO_MAKEFILE_TPL
NVCC = nvcc
CPPC = g++
CC = g++

NVCCFLAGS = -g -O2 -I/usr/include/libxml2/
CPPFLAGS = $(NVCCFLAGS)
CFLAGS = $(NVCCFLAGS)

LDFLAGS = -lxml2

HDR= $(wildcard *.h)

all:EASEA.out


EASEA.out: tool/tool.o EASEAIndividual.o EASEA.o EASEAGPUEval.o
			    $(NVCC) -o $@ $^ $(LDFLAGS) $(NVCCFLAGS)

tool/%.o:tool/%.c tool/%.h
			    $(CC) -c -o $@ $< $(CFLAGS)

%.o:%.cpp $(HDR)
			    $(CPPC) -c -o $@ $< $(CPPFLAGS)

%.o:%.cu $(HDR)
			    $(NVCC) -c -o $@ $< $(NVCCFLAGS) --device-emulation

clean:
			    rm *.o EASEA.out
 
\TEMPLATE_END
