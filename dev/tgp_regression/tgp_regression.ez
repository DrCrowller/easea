/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
__________________________________________________________*/

\User declarations :
//#include <gsl/gsl_rng.h>
#include <assert.h>
#include <errno.h>
#include <sstream>
#include <fstream>
#include <math.h>
#include <pthread.h>
<<<<<<< HEAD

=======
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7


#include <cutil.h>
#include <cuda_runtime_api.h>
#define TIMING 
#include <sys/time.h>
#include <timing.h>
#include <semaphore.h>

#define  OPERAND 0
<<<<<<< HEAD
int NB_FITNESS_CASES=32;
// number of input variables
#define VAR_LEN 1
#define DRONE_VAR_LEN 19
=======
#define NB_FITNESS_CASES 128


// number of input variables
#define VAR_LEN 4
#define DRONE_VAR_LEN 4
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7

// Here, some well known parameters for GP.
#define MAX_ARITY 2          // maximum arrity for GP nodes
#define NB_TREES 1           // number of co-evolved trees
#define TREE_DEPTH_MIN 8     // minimum size of (initial) trees (included)
#define TREE_DEPTH_MAX 9     // maximum size of (initial) trees (excluded)
#define GROW_FULL_RATIO 0.5  // ratio between grow and full construction method
#define DIV_ERR_VALUE 1.0      // Returned value, in case of non defined input value
#define MAX_XOVER_DEPTH 17
#define MAX_MUTAT_DEPTH 17

// Here, some GPGPGPU parameters
#define MAX_PROGS_SIZE 20000000

float** inputs;
float** outputs;
<<<<<<< HEAD
float* inputs_f = NULL;
float* outputs_f = NULL;
=======

float* inputs_f = NULL;
float* outputs_f = NULL;

>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
float* input_k;
float* output_k;
float* progs     = NULL;
float* progs_k   = NULL;
int* indexes     = NULL;
int* indexes_k   = NULL;
int* hits      = NULL;
int* hits_k    = NULL;
float* results   = NULL;
float* results_k = NULL;

int nbGPU = 0;

//#define MULTI_GPU
FILE* gpu_stat_file = NULL;



int nbGPU = 0;
#define GPUEVAL 128
#define GPUMINDIV 1
//#define CPUEVAL
//#define CPUCMP
#define MULTI_GPU
//#define INSTRUMENTED 

#ifdef INSTRUMENTED
struct stats{
  struct timeval cpu_eval_res;
  struct timeval gpu_eval_res;
  struct timeval flat_trees_res;
  int popSize;
  int err;
  int gpu0Blen;
  int gpu1Blen;
  int bLen;
  float bestF;
  int bestH;
  float meanF;
  float stdDevF;
};
struct stats currentStats;
#endif

#ifdef INSTRUMENTED
FILE* gpu_stat_file = NULL;
#endif
int fitnessCasesSetLength;

/** For the sake of simplicity, constant operators become first in the function set
    Koza defines 2 operator sets, one for constants, another for function.

    @TODO
    Terminal variables could be encoded differently, for example using one opCode for every
    variable, and another field to encode the id of the variable (what about the likelyhood of having 
    each variable (this sould divide by the number of variables)
*/
//#define OP 1
#if 1
enum OPCODE               { OP_ERC, OP_W, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OP_SIN, OP_COS, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "*"   , "+"   , "-"   , "/"   , "sin" , "cos" };
int opArrity[] =          { 0     , 0   , 2     , 2     , 2     , 2     , 1     , 1     };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#define OP_X -1
#define OP_Y -2
#define OP_Z -3
#endif

#if 0
enum OPCODE               { OP_ERC, OP_W, OP_MUL, OP_ADD, OP_SUB, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "*"   , "+"   , "-"   };
int opArrity[] =          { 0     ,  0   , 2     , 2     , 2    };
int constLen = 2;
int totalLen = OPCODE_SIZE;
<<<<<<< HEAD
#define OP_X -1
#define OP_Y -2
#define OP_Z -3
#endif
=======
#endif

>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
#if 0
enum OPCODE               { OP_ERC, OP_W, OP_MUL, OP_ADD, OP_SUB,  OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "*"   , "+"   , "-"   ,  "/"};
int opArrity[] =          { 0     ,  0   , 2     , 2     , 2    ,  2  };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#define OP_X -1
#define OP_Y -2
#define OP_Z -3
#endif

<<<<<<< HEAD
#if 0
enum OPCODE               { OP_ERC, OP_W, OP_X, OP_Y, OP_Z, OP_MUL, OP_ADD, OP_SUB,  OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "x" , "y" , "z" ,"*"   , "+"   , "-"   ,  "/"};
int opArrity[] =          { 0     ,  0  , 0   , 0   , 0   ,2     , 2     , 2    ,  2  };
const int constLen = 5;
const int totalLen = OPCODE_SIZE;
#endif
=======

#if 1
enum OPCODE               { OP_ERC, OP_W, OP_X, OP_Y, OP_Z, OP_MUL, OP_ADD, OP_SUB,  OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "x" , "y" , "z" ,"*"   , "+"   , "-"   ,  "/"};
int opArrity[] =          { 0     ,  0  , 0   , 0   , 0   ,2     , 2     , 2    ,  2  };
int constLen = 5;
int totalLen = OPCODE_SIZE;
#endif

#define OUTPUT_DATA_ID 0

#include "tgp_regressionEval.cu"
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7



#if 0
enum OPCODE               { OP_ERC, OP_VAR, OP_MUL, OP_ADD, OP_SUB,  OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w"   , "*"   , "+"   , "-"   ,  "/"};
int opArrity[] =          { 0     ,  0    , 2     , 2     , 2     ,  2  };
const int constLen = 2;
const int totalLen = OPCODE_SIZE;
#endif


#define OUTPUT_DATA_ID 0
#include "tgp_regressionEval.cu"
\end

\User functions:
#define PI (3.141592653589793)
#define MILLION_I 1000000

struct timeval global_eval_beg, global_eval_end, global_eval_res;
struct timeval global_eval_acc;    
//DECLARE_TIME_ACC(global_eval);

/* Convert a timeval to microseconds as a long */
long misc_tv_usec_l(struct timeval *t){
  return ((long) t->tv_sec * MILLION_I) + t->tv_usec;
}

#ifdef INSTRUMENTED
void publish_mgpu_32(){
  fprintf(gpu_stat_file,",,%ld,",EA->getCurrentGeneration());

  fprintf(gpu_stat_file,"%d,%d,%f,%d,",currentStats.gpu0Blen,currentStats.gpu1Blen,(double)currentStats.gpu0Blen/currentStats.gpu1Blen,currentStats.bLen);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.flat_trees_res.tv_sec,currentStats.flat_trees_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.cpu_eval_res.tv_sec,currentStats.cpu_eval_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.gpu_eval_res.tv_sec,currentStats.gpu_eval_res.tv_usec);

  double speedUp = misc_tv_usec_l(&currentStats.cpu_eval_res)/misc_tv_usec_l(&currentStats.gpu_eval_res);
  fprintf(gpu_stat_file,"%0.0f,%0f,",speedUp,(double)(currentStats.popSize-currentStats.err)/(double)currentStats.popSize);
  fprintf(gpu_stat_file,"%f,%d,",currentStats.bestF,currentStats.bestH);
  fprintf(gpu_stat_file,"%f,%f,",currentStats.meanF,currentStats.stdDevF);
  fprintf(gpu_stat_file,"\n");
  fflush(gpu_stat_file);
}
#endif


/** This function allows one to load .csv file for 1 input variables.T he file must start with the number
    of fitness cases, then it has to contain every inputs values, finally outputs values for each point : 
    x[0,1], x[0,2], ..., x[0,n], f(x[0])
    x[1,1], x[1,2], ..., x[1,n], f(x[1])
    ...
    x[m,1], x[m,2], ..., x[m,n], f(x[m])

    This function allocates inputs and outputs wrt the size written in the file*/
int load_data(float*** inputs, float*** outputs, string filename){
  int i;
  FILE* file = fopen(filename.c_str(),"r");
  int loaded_size;
  int match = 0;
  int variable;

  if( !file ){
    fprintf(stderr,"ERROR : input file (%s) cannot be opened\n",filename.c_str());
    exit(-1);
  }

  match = fscanf(file,"%d\n",&loaded_size);
  assert(match==1);

  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float**)malloc(sizeof(**outputs)*loaded_size);
  
  for( i=0 ; i<loaded_size ; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*VAR_LEN);
    for( variable=0 ; variable<VAR_LEN ; variable++ ){   
      match = fscanf(file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    (*outputs)[i] = (float*)malloc(sizeof(**outputs)*NB_TREES);
    for( int output_vals = 0 ; output_vals<NB_TREES ; output_vals++ ){
      match = fscanf(file,"%f,\n",(*outputs)[i]+output_vals);
      assert(match==1);
    }
  }
  fclose(file);
  return loaded_size;
}

<<<<<<< HEAD

/**
   This function allows to load data from the Stephane output file format (mostly csv file),
   with multiple input variables and one result.

   It loads DRONE_VAR_LEN input variables and the the OUTPUT_DATA_ID th output result.
   
   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)
   @name name of the input file.

   @ret number of loaded fitness cases (should be equal to NB_FITNESS_CASES).
 */
int load_drone_data(float*** inputs, float*** outputs,const string& name){

  FILE* file = fopen(name.c_str(),"r");
  if( !file ){
    perror("Opening drone data file");
    exit(-1);
  }
  int match;
  int loaded_size = NB_FITNESS_CASES;
  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float**)malloc(sizeof(**outputs)*loaded_size);

  for( int i=0 ; i<loaded_size; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*DRONE_VAR_LEN);
    for( int variable=0 ; variable<DRONE_VAR_LEN ; variable++ ){
      match = fscanf(file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    (*outputs)[i] = (float*)malloc(sizeof(**outputs)*NB_TREES);
    float useless_input=0;
    for( int dump_input_data=0 ; dump_input_data<OUTPUT_DATA_ID; dump_input_data++ ){
      match = fscanf(file,"%f,\n",&useless_input);
      assert(match==1);
    }
    for( int output_vals = 0 ; output_vals<NB_TREES ; output_vals++ ){
      match = fscanf(file,"%f,\n",(*outputs)[i]+output_vals);
      assert(match==1);
    }
    char dump_junk[512];
    fgets(dump_junk,512,file);
  }
  fclose(file);
  return loaded_size;
}


int load_drone_data(float*** data, const string& name){
  FILE* file = fopen(name.c_str(),"r");
  if( !file ){
    perror("Opening drone data file");
    exit(-1);
  }
  int match;
  int loaded_size = NB_FITNESS_CASES;

  (*data) = (float**)malloc(sizeof(*data)*loaded_size);
  for( int i=0 ; i<loaded_size; i++){
    (*data)[i] = (float*)malloc(sizeof(**data)*DRONE_VAR_LEN);
    for( int variable=0 ; variable<DRONE_VAR_LEN ; variable++ ){
      match = fscanf(file,"%f,",((*data)[i])+variable);
      assert(match==1);
    }
  }
  return loaded_size;
}


//#define POLY(x) x*x*x*x*x*x-2*x*x*x*x+x*x
//#define POLY_NAME "sextic regression"
#define POLY(x) cos(2*x)
#define POLY_NAME "cos 2x regression"
/**
   This function generates data NB_FITNESS_CASES fitness cases,
   from the polynome POLY(X) with X randomly picked between (-1,1)

   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)

=======

/**
   This function allows to load data from the Stephane output file format (mostly csv file),
   with multiple input variables and one result.

   It loads DRONE_VAR_LEN input variables and the the OUTPUT_DATA_ID th output result.
   
   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)
   @name name of the input file.

   @ret number of loaded fitness cases (should be equal to NB_FITNESS_CASES).
 */
int load_drone_data(float*** inputs, float*** outputs,const string& name){

  FILE* drone_data_file = fopen(name.c_str(),"r");
  int match;
  int loaded_size = NB_FITNESS_CASES;
  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float**)malloc(sizeof(**outputs)*loaded_size);

  for( int i=0 ; i<loaded_size; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*DRONE_VAR_LEN);
    for( int variable=0 ; variable<DRONE_VAR_LEN ; variable++ ){
      match = fscanf(drone_data_file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    (*outputs)[i] = (float*)malloc(sizeof(**outputs)*NB_TREES);
    float useless_input=0;
    for( int dump_input_data=0 ; dump_input_data<OUTPUT_DATA_ID; dump_input_data++ ){
      match = fscanf(drone_data_file,"%f,\n",&useless_input);
      assert(match==1);
    }
    for( int output_vals = 0 ; output_vals<NB_TREES ; output_vals++ ){
      match = fscanf(drone_data_file,"%f,\n",(*outputs)[i]+output_vals);
      assert(match==1);
    }
    char dump_junk[512];
    fgets(dump_junk,512,drone_data_file);
  }
  return loaded_size;
}




#define POLY(x) x*x*x*x*x*x-2*x*x*x*x+x*x
/**
   This function generates data NB_FITNESS_CASES fitness cases,
   from the polynome POLY(X) with X randomly picked between (-1,1)

   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)

>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
   @ret number of loaded fitness cases (should be equal to NB_FITNESS_CASES).   
 */
int generateData(float*** inputs, float*** outputs){
  int i=0;

  (*inputs) = (float**)malloc(sizeof(**inputs)*NB_FITNESS_CASES);
  (*outputs) = (float**)malloc(sizeof(**outputs)*NB_FITNESS_CASES);

  for( i=0 ; i<NB_FITNESS_CASES ; i++ ){
    (*inputs)[i]=(float*)malloc(sizeof(***inputs));
    (*outputs)[i]=(float*)malloc(sizeof(***outputs));
    float x = random(0.,(float)2*PI);
    (*inputs)[i][0] = x;
    (*outputs)[i][0] = POLY(x);
  }

  return NB_FITNESS_CASES;
}


void free_data(){
  for( int i=0 ; i<fitnessCasesSetLength ;i++ )
    free( inputs[i] );
  for( int i=0 ; i<NB_TREES ; i++ )
    free( outputs[i] );
  free( inputs );
  free( outputs );
}

/**
   Recursive construction method for trees.
   Koza construction methods. Function set has to be ordered,
   with first every terminal nodes and then non-terminal.

   @arg constLen : length of terminal function set.
   @arg totalLen : length of the function set (non-terminal+terminal)
   @arg currentDepth : depth of the origin (sould always be 0, when the function
   is directly call)
   @arg maxDepth : The maximum depth of the resulting tree.
   @arg full : whether the construction method used has to be full (from koza's book)
   Otherwise, it will use grow method (defined in the same book).
 
   @return : pointer to the root node of the resulting sub tree
*/
GPNode* construction_method( const int constLen, const int totalLen , const int currentDepth,
			     const int maxDepth, const bool full, GPNode* parentPtr){
  GPNode* node = new GPNode();
  // first select the opCode for the current Node.
  if( full ){
    if( currentDepth<maxDepth ) node->opCode = random(constLen,totalLen);
    else node->opCode = random(0, constLen);
  }
  else{
    if( currentDepth<maxDepth ) node->opCode = random(0, totalLen);
    else node->opCode = random(0, constLen);
  }
 
  int arity = opArrity[(int)node->opCode];
  node->currentArity = arity;

  // construct children (if any)
  for( int i=0 ; i<arity ; i++ )
    node->children[i] = construction_method(constLen, totalLen, currentDepth+1, maxDepth, full, node);
  
  // affect null to other array cells (if any)
  for( int i=arity ; i<MAX_ARITY ; i++ )
    node->children[i] = NULL;

  if( node->opCode==OP_ERC ){
    node->erc_value = random(0.,1.);
  }

  return node;
}

/**
   This function handles printing of tree.
   Every node is identify by its address, in memory,
   and labeled by the actual opCode.

   On our architecture (64bits, ubuntu 8.04/9.04 and gcc-4.3.2)
   the long int variable is sufficient to store the address
   without any warning.
*/
void toDotFile_r(GPNode* root, FILE* outputFile){
  if( root->opCode==OP_ERC )
    fprintf(outputFile," %ld [label=\"%s : %f\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str(),
	    root->erc_value);
  else
    fprintf(outputFile," %ld [label=\"%s\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str());
  
  for( int i=0 ; i<root->currentArity ; i++ ){
    if( root->children[i] ){
      fprintf(outputFile,"%ld -> %ld;\n", (long int)root, (long int)root->children[i]);
      toDotFile_r( root->children[i] , outputFile);
    }
  }
}

/**
   This function prints a tree in dot (graphviz format).
   This is the entry point for the print operation. (see toDotFile_r,
   for the actual function)

   @arg root : set of trees, same type than in a individual.
   @arg baseFileName : base of filename for the output file.
   @arg treeId : the id of the tree to print, in the given set.
*/
void toDotFile(GPNode* root, const char* baseFileName, int treeId){
  std::ostringstream oss;
  oss << baseFileName << "-" << treeId << ".gv";

  FILE* outputFile = fopen(oss.str().c_str(),"w");
  if( !outputFile ){
    perror("Opening file for outputing dot representation ");
    exit(-1);
  }

  fprintf(outputFile,"digraph trees {\n");
  if(root)
    toDotFile_r( root, outputFile);
  fprintf(outputFile,"}\n");
  fclose(outputFile);
}


/**
   Compute the maximum depth of a tree, rooted on root.

   @arg root : root of the tree
   @return : depth of current tree rooted on root
*/
int depthOfTree(GPNode* root){
  int depth = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    int d = depthOfTree(root->children[i]);
    if( d>=depth ) depth = d;
  }
  return depth+1;
}


/**
   Recursively evaluate tree for given inputs   
*/
<<<<<<< HEAD
float recEvaleDrone(GPNode* root, float** data) {
  if( root->currentArity==2 ){
    float a=recEvaleDrone(root->children[0],data);
    float b=recEvaleDrone(root->children[1],data);
    switch( root->opCode ){
    case OP_MUL: return a*b;
    case OP_ADD: return a+b;
    case OP_SUB: return a-b;
    case OP_DIV:
      if( !b ) return DIV_ERR_VALUE;
      else return a/b;
    default:
      fprintf(stderr,"unknown binary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else if( root->currentArity==1 ){
    float a=recEvaleDrone(root->children[0],data);
    switch( root->opCode ){
    case OP_SIN: return sinf(a);
    case OP_COS: return cosf(a);
      /*     case OP_EXP: return exp(a); */
    default:
      fprintf(stderr,"unknown unary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else
    switch( root->opCode ){
    case OP_ERC: return root->erc_value;
      //case OP_VAR: return inputs[0];
    default:
      fprintf(stderr,"unknown terminal opcode %d\n",root->opCode);
      exit(-1);
    }
}


/**
   Recursively evaluate tree for given inputs   
*/
=======
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
float recEvale(GPNode* root, float* inputs){
  if( root->currentArity==2 ){
    float a=recEvale(root->children[0],inputs);
    float b=recEvale(root->children[1],inputs);
    switch( root->opCode ){
    case OP_MUL: return a*b;
    case OP_ADD: return a+b;
    case OP_SUB: return a-b;
    case OP_DIV:
      if( b==0 ) return DIV_ERR_VALUE;
      else return a/b;
    default:
      fprintf(stderr,"unknown binary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else if( root->currentArity==1 ){
    float a=recEvale(root->children[0],inputs);
    switch( root->opCode ){
<<<<<<< HEAD
    case OP_SIN: return sinf(a);
    case OP_COS: return cosf(a);
=======
      /*     case OP_SIN: return sin(a); */
      /*     case OP_COS: return cos(a); */
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
      /*     case OP_EXP: return exp(a); */
    default:
      fprintf(stderr,"unknown unary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else
    switch( root->opCode ){
    case OP_ERC: return root->erc_value;
    case OP_W: return inputs[0];
    case OP_X: return inputs[1];
    case OP_Y: return inputs[2];
    case OP_Z: return inputs[3];
    default:
      fprintf(stderr,"unknown terminal opcode %d\n",root->opCode);
      exit(-1);
    }
}


/**
   Fill the collection array with GPNode located at goalDepth

   @arg goalDepth: level from which GPNode are collected
   @arg collection: an empty, allocated array
*/
int collectNodesDepth(const int goalDepth, GPNode** collection, int collected, int currentDepth, GPNode* root){

  if( currentDepth>=goalDepth ){
    collection[collected] = root;
    return collected+1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      collected=collectNodesDepth(goalDepth, collection, collected, currentDepth+1, root->children[i]);
    }
    return collected;
  }
}


/**
   Pick a node in a tree. It first pick a depth and then, it pick a
   node amongst nodes at this depth. It returns the parent node,
   and by pointer, the childId of the choosen child.

   @arg root : the root node of the tree, amongt which we have to choose the node
   @arg chilId : pointer to an allocated int, children position of the choosen node will be stored here
   @arg depth : pointer to an allocated int, will contain the choosen depth.

   @return : return the address of the parent of the choosen node. Return null if the root node has been choosen
*/
GPNode* selectNode( GPNode* root, int* childId, int* depth){
  
  int xoverDepth = random(0,depthOfTree(root));
  (*depth) = xoverDepth;
  
  GPNode** dNodes;
  int collected;

  if(xoverDepth!=0){
    dNodes = new GPNode*[1<<(xoverDepth-1)];
    collected = collectNodesDepth(xoverDepth-1,dNodes,0,0,root);
  }
  else{
    return NULL;
  }
  int stockPointCount=0;
  for( int i=0 ; i<collected; i++ ){
    stockPointCount+=dNodes[i]->currentArity;
  }

  int reminderP = 0, parentIndexP = 0;

  int xoverP = random(0,stockPointCount);
  for( int i=0 ; ; )
    if( (i+dNodes[parentIndexP]->currentArity)>xoverP ){
      reminderP = xoverP-i;
      break;
    }
    else i+=dNodes[parentIndexP++]->currentArity;
  
  *childId = reminderP;
  //cout << "d of x : " << xoverDepth << "/" << depthOfTree(root)<< " n : "<< xoverP << endl;
  GPNode* ret = dNodes[parentIndexP];
  delete[] dNodes;
  return ret;
}
			 
void flattenDatas( float** inputs, int length, int width, float** flat_inputs){
  (*flat_inputs)=(float*)malloc(sizeof(float)*length*width);
  for( int i=0 ; i<length ; i++ ){
    for( int j=0 ; j<width ; j++ ){
      (*flat_inputs)[i*width+j] = inputs[i][j];
    }
  }
}



/**
   Send input and output data on the GPU memory.
   Allocate
*/
void initialDataToGPU(float* input_f, int length_input, float* output_f, int length_output){
  printf("is : %d, os : %d\n",length_input, length_output);
  // allocate and copy input/output arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)(&input_k),sizeof(float)*length_input));
  CUDA_SAFE_CALL(cudaMalloc((void**)(&output_k),sizeof(float)*length_output));
  CUDA_SAFE_CALL(cudaMemcpy(input_k,input_f,sizeof(float)*length_input,cudaMemcpyHostToDevice));
  CUDA_SAFE_CALL(cudaMemcpy(output_k,output_f,sizeof(float)*length_output,cudaMemcpyHostToDevice));

  // allocate indexes and programs arrays
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);
  CUDA_SAFE_CALL(cudaMalloc((void**)&indexes_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL( cudaMalloc((void**)&progs_k,sizeof(*progs_k)*MAX_PROGS_SIZE));

  // allocate hits and results arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)&results_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL(cudaMalloc((void**)&hits_k,sizeof(*indexes_k)*maxPopSize));
}

/**
   Free gpu memory from the input and ouput arrays.
*/
void free_gpu(){
  cudaFree(input_k);
  cudaFree(output_k);
  cudaFree(progs_k);
  cudaFree(indexes_k);
  cout << "GPU freed" << endl;
}


int flattening_tree_rpn( GPNode* root, float* buf, int* index){
  int i;

  for( i=0 ; i<root->currentArity ; i++ ){
    flattening_tree_rpn(root->children[i],buf,index);
  }
  if( (*index)+2>MAX_PROGS_SIZE )return 0;
  buf[(*index)++] = root->opCode;
  if( root->opCode == OP_ERC ) buf[(*index)++] = root->erc_value;
  return 1;
}

int enumTreeNodes(GPNode* root){
  int nbNode = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    nbNode+=enumTreeNodes(root->children[i]);
  }
  return nbNode+1;
}


GPNode* pickNthNode(GPNode* root, int N, int* childId){
  
  GPNode* stack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  GPNode* parentStack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  int stackPointer = 0;

  parentStack[stackPointer] = NULL;
  stack[stackPointer++] = root;

  for( int i=0 ; i<N ; i++ ){
    GPNode* currentNode = stack[stackPointer-1];
    //cout <<  currentNode << endl;
    stackPointer--;
    for( int j=currentNode->currentArity ; j>0 ; j--){
      parentStack[stackPointer] = currentNode;
      stack[stackPointer++] = currentNode->children[j-1];
    }
  }

  //assert(stackPointer>0);
  if( stackPointer )
    stackPointer--;
  
  //cout << "f : \n\t n :" << stack[stackPointer ] << "\n\t p :" << parentStack[stackPointer] << " cId : " << (*childId) << endl;
  
  for( int i=0 ; i<parentStack[stackPointer]->currentArity ; i++ ){
    if( parentStack[stackPointer]->children[i]==stack[stackPointer] ){
      (*childId)=i;
      break;
    }
  }
  

  return parentStack[stackPointer];
}


int depthOfNode(GPNode* root, GPNode* node){

  if( root==node ){
    return 1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      int depth = depthOfNode(root->children[i],node);
      if( depth )
	return depth+1;
    }
    return 0;
  }
}

void simpleCrossOver(IndividualImpl& p1, IndividualImpl& p2, IndividualImpl& c){
  int depthP1 = depthOfTree(p1.root[0]);
  int depthP2 = depthOfTree(p2.root[0]);

  int nbNodeP1 = enumTreeNodes(p1.root[0]);
   int nbNodeP2 = enumTreeNodes(p2.root[0]);

  int stockPointChildId=0;
  int graftPointChildId=0;

  bool stockCouldBeTerminal = tossCoin(0.1);
  bool graftCouldBeTerminal = tossCoin(0.1);

  int childrenDepth = 0, Np1 = 0 , Np2 = 0;
  GPNode* stockParentNode = NULL;
  GPNode* graftParentNode = NULL;

  do{
  choose_node:
    /* Np1 = (int)random((int)0,(int)nbNodeP1); */
    /* Np2 = (int)random((int)0,(int)nbNodeP2); */

    if( nbNodeP1<2 ) Np1=0;
    else Np1 = (int)random((int)0,(int)nbNodeP1);
    if( nbNodeP2<2 ) Np2=0;
    else Np2 = (int)random((int)0,(int)nbNodeP2);

    
    if( Np1!=0 ) stockParentNode = pickNthNode(c.root[0], MIN(Np1,nbNodeP1) ,&stockPointChildId);
    if( Np2!=0 ) graftParentNode = pickNthNode(p2.root[0], MIN(Np2,nbNodeP1) ,&graftPointChildId);

    // is the stock and the graft an authorized type of node (leaf or inner-node)
    if( Np1 && !stockCouldBeTerminal && stockParentNode->children[stockPointChildId]->currentArity==0 ) goto choose_node;
    if( Np2 && !graftCouldBeTerminal && graftParentNode->children[graftPointChildId]->currentArity==0 ) goto choose_node;
    
    if( Np2 && Np1)
      childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthOfTree(graftParentNode->children[graftPointChildId]);
    else if( Np1 ) childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthP1;
    else if( Np2 ) childrenDepth = depthOfTree(graftParentNode->children[graftPointChildId]);
    else childrenDepth = depthP2;
    
  }while( childrenDepth>MAX_XOVER_DEPTH );
  
  if( Np1 && Np2 ){
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }
  else if( Np1 ){ // && Np2==NULL
    // We want to use the root of the parent 2 as graft
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = p2.root[0];
    p2.root[0] = NULL;
  }else if( Np2 ){ // && Np1==NULL
    // We want to use the root of the parent 1 as stock
    delete c.root[0];
    c.root[0] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }else{
    // We want to switch root nodes between parents
    delete c.root[0];
    c.root[0]  = p2.root[0];
    p2.root[0] = NULL;
  }

  //toDotFile(c.root[0],"out/xover/cf",0);
}

<<<<<<< HEAD

void treeGP_to_cr(const GPNode* root, ostringstream& oss){


  if( root->currentArity == 2 ){
    oss << "(" ;
    treeGP_to_cr(root->children[0],oss);
    oss <<  opCodeName[root->opCode] ;
    treeGP_to_cr(root->children[1],oss);
    oss << ")";
  }
  else if( root->currentArity==1 ){
    oss << opCodeName[root->opCode] << "(";
    treeGP_to_cr(root->children[0],oss);
    oss << ")";
  }
  else if( root->currentArity==0 ){
    if( root->opCode==OP_ERC )
      oss << root->erc_value;
    else 
      oss << opCodeName[root->opCode] ;


  }
  else{
    cerr << "unexpected arity " << endl;
    exit(-1);
  }
}
=======
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7

void treeGP_to_cr(const GPNode* root, ostringstream& oss){


  if( root->currentArity == 2 ){
    oss << "(" ;
    treeGP_to_cr(root->children[0],oss);
    oss <<  opCodeName[root->opCode] ;
    treeGP_to_cr(root->children[1],oss);
    oss << ")";
  }
  else if( root->currentArity==1 ){
    oss << opCodeName[root->opCode] << "(";
    treeGP_to_cr(root->children[0],oss);
    oss << ")";
  }
  else if( root->currentArity==0 ){
    if( root->opCode==OP_ERC )
      oss << root->erc_value;
    else 
      oss << opCodeName[root->opCode] ;


  }
  else{
    cerr << "unexpected arity " << endl;
    exit(-1);
  }
}


string treeGP_to_c(const GPNode* root){
  ostringstream oss;
  
  treeGP_to_cr(root,oss);
  
  return oss.str();
}

\end

string treeGP_to_c(const GPNode* root){
  ostringstream oss;
  
  treeGP_to_cr(root,oss);
  
  return oss.str();
}


class HitGoal : public CStoppingCriterion{
  
  bool reached(){
    return false;
  }
};

<<<<<<< HEAD

\end
// end of user definition body

=======
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
 
\Before everything else function:
{
global_eval_acc.tv_sec = 0.;                                 
global_eval_acc.tv_usec = 0.;

#ifdef CPUEVAL
  printf("eval on CPU\n");
#endif
#ifdef GPUEVAL
  printf("eval on GPU\n");
#endif

  NB_FITNESS_CASES = setVariable("u3",NB_FITNESS_CASES);
  cout << "nb of ordered fc : " << NB_FITNESS_CASES << endl;
 
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);
   // load data from csv file.
  cout<<"Before everything else function called "<<endl;
  //fitnessCasesSetLength = load_data(&inputs,&outputs,"data_koza_sextic.csv");
<<<<<<< HEAD
  fitnessCasesSetLength = generateData(&inputs,&outputs);
  //fitnessCasesSetLength = load_drone_data(&inputs,&outputs,"data_drone/data_sample1-100.csv");
  //fitnessCasesSetLength = load_drone_data(&inputs,"data_drone/data_sample1-100.csv");
=======
  //fitnessCasesSetLength = generateData(&inputs,&outputs);
  fitnessCasesSetLength = load_drone_data(&inputs,&outputs,"data_drone/data_drone.csv");
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
  cout << "number of point in fitness cases set : " << fitnessCasesSetLength << endl;

  inputs_f = NULL;
  outputs_f = NULL;

  flattenDatas(inputs,fitnessCasesSetLength,VAR_LEN,&inputs_f);
  flattenDatas(outputs,fitnessCasesSetLength,NB_TREES,&outputs_f);

  /* for( int i=0 ;i<fitnessCasesSetLength ; i++ ) */
  /*   printf("%f,",inputs[i][0]); */
  /* printf("\n"); */
  /* for( int i=0 ;i<fitnessCasesSetLength ; i++ ) */
  /*   printf("%f,",outputs[i][0]); */
  /* printf("\n"); */
  

  indexes = new int[maxPopSize];
  hits    = new int[maxPopSize];
  results = new float[maxPopSize];
  progs   = new float[MAX_PROGS_SIZE];
  
  INSTEAD_EVAL_STEP=true;
  
  // Adding another stopping, as we are minimizing, the goal is 0
  /* CGoalCriterion* gc = new CGoalCriterion(0,true); */
  /* EA->stoppingCriteria.push_back(gc); */
<<<<<<< HEAD
  HitGoal* hg = new HitGoal();
  EA->stoppingCriteria.push_back(hg);

#ifdef MULTI_GPU

  // This section implements the multi-gpu approach
  int count;
  cudaGetDeviceCount(&count);
  printf("Number of devices : %d\n", count);

  pthread_t* t = (pthread_t*)malloc(sizeof(pthread_t)*count);
  gpuArgs = (struct gpuArg*)malloc(sizeof(struct gpuArg)*count);

  nbGPU = count;
  // here we want to create one thread per GPU
  for( int i=0 ; i<count ; i++ ){
    gpuArgs[i].threadId = i;

=======

#ifdef MULTI_GPU

  // This section implements the multi-gpu approach
  int count;
  cudaGetDeviceCount(&count);
  printf("Number of devices : %d\n", count);

  pthread_t* t = (pthread_t*)malloc(sizeof(pthread_t)*count);
  gpuArgs = (struct gpuArg*)malloc(sizeof(struct gpuArg)*count);

  nbGPU = count;
  // here we want to create one thread per GPU
  for( int i=0 ; i<count ; i++ ){
    gpuArgs[i].threadId = i;

>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
    sem_init(&gpuArgs[i].sem_in,0,0);
    sem_init(&gpuArgs[i].sem_out,0,0);

    if( pthread_create(t+i,NULL,gpuThreadMain,gpuArgs+i) ) 
      perror("pthread_create : "); 
  }
<<<<<<< HEAD
=======
  
 
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
#else
  nbGPU=1;
  // Here starts the CUDA parts
  cudaSetDevice(1); // on GTX295 ;) we want to use the second card for computation
  initialDataToGPU(inputs_f, fitnessCasesSetLength*VAR_LEN, outputs_f, fitnessCasesSetLength*NB_TREES);
#endif
  cout << "seed is : " << EA->params->seed << endl;

<<<<<<< HEAD
#ifdef INSTRUMENTED
  ostringstream output_file_name;

  output_file_name << "stats/gpu_stat_file" << "-ps" << EA->params->parentPopulationSize << "-os" << EA->params->offspringPopulationSize 
		   << "-fc" << NB_FITNESS_CASES << "-s"<< EA->params->seed <<".csv";
  // gpu statistics file
  gpu_stat_file = fopen(output_file_name.str().c_str(),"a");
  fprintf(gpu_stat_file,"seed,%ld\n",EA->params->seed);
  fprintf(gpu_stat_file,"blockDim,%d\n",GPUEVAL);
  fprintf(gpu_stat_file,"indivPerBlock,%d\n",(GPUEVAL==32?GPUMINDIV:1));
  fprintf(gpu_stat_file,"nbGPU,%d\n",nbGPU);
  fprintf(gpu_stat_file,"FitCaseLen,%d\n",fitnessCasesSetLength);

  for( int i=0 ; i<OPCODE_SIZE ; i++ )
    fprintf(gpu_stat_file,"%s,",opCodeName[i].c_str());
  fprintf(gpu_stat_file,"\n");
  
  fprintf(gpu_stat_file,"problem name,%s\n",POLY_NAME);

  fprintf(gpu_stat_file,",,gen,");
#ifdef MULTI_GPU
  for( int i=0 ; i<nbGPU ; i++ )
    fprintf(gpu_stat_file,"G%d Blezn,",i);
  fprintf(gpu_stat_file,"buf ratio,");
#endif
#ifdef GPUEVAL
  fprintf(gpu_stat_file,"total pLen,");
  fprintf(gpu_stat_file,"ftime,gpuETime,");
#endif
#ifdef CPUEVAL
  fprintf(gpu_stat_file,"cpuETime,SU,");
#endif
#ifdef CPUCMP
  fprintf(gpu_stat_file,"correct ratio,");
#endif
  fprintf(gpu_stat_file,"bestF,bestH,avgF,stdDevF\n");
=======
  // gpu statistics file
  gpu_stat_file = fopen("gpu_stat_file.csv","w");
  fprintf(gpu_stat_file,"seed :,%ld\n",EA->params->seed);
  fprintf(gpu_stat_file,"nbGPU :,%d\n",nbGPU);
  fprintf(gpu_stat_file,"FitCaseLen :,%d\n",fitnessCasesSetLength);

#ifdef MULTI_GPU
  fprintf(gpu_stat_file,"gen, G1 Blen, G2 Blen, buf ratio, Ftime, cpu Etime, gpu Etime, speedup, correct ratio\n");
#else
  fprintf(gpu_stat_file,"gen, Ftime, cpu Etime, gpu Etime, speedup, correct ratio\n");
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
#endif
}
\end

\After everything else function:
{
  // write tree of every individuals in a separate file.
  /* for( unsigned int i=0 ; i<population->actualParentPopulationSize ; i++ ){ */
  /*   std::ostringstream oss; */
  /*   oss << "out/indiv-" << i << "-trees" ; */
  /*   toDotFile( ((IndividualImpl*)population->parents[i])->root[0],oss.str().c_str(),0); */
  /* } */

  // not sure that the population is sorted now. So lets do another time (or check in the code;))
  // and dump the best individual in a graphviz file.
  population->sortParentPopulation();
  toDotFile( ((IndividualImpl*)population->parents[0])->root[0], "best-of-run",0);
  // here we will dump a c-like expression of the same individual
  ofstream fichier("best-of-run.exp", ios::out | ios::trunc);
  fichier << treeGP_to_c( ((IndividualImpl*)population->parents[0])->root[0] ) << endl;
  fichier.close();
  
  // delete some global arrays
  delete[] indexes; delete[] hits;
  delete[] results; delete[] progs;
  
#ifdef MULTI_GPU
  freeGPU=true;
  wake_up_gpu_thread(nbGPU);
#else
  free_gpu();
#endif
  free_data();
<<<<<<< HEAD

#ifdef INSTRUMENTED
  fclose(gpu_stat_file);
#endif
  SHOW_TIME_ACC(global_eval);
=======
  fclose(gpu_stat_file);
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
}
\end

\At the beginning of each generation function:
  //cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
{
  //cout << "At the end of each generation function called" << endl;
#ifdef INSTRUMENTED
  currentStats.bestF = EA->population->Best->fitness;
  currentStats.bestH = ((IndividualImpl*)EA->population->Best)->hits;
  currentStats.meanF = EA->currentAverageFitness;
  currentStats.stdDevF = EA->currentSTDEV;
  publish_mgpu_32();
#endif
}
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\Instead evaluation function:
{
<<<<<<< HEAD
  TIME_ST(global_eval);
#ifdef GPUEVAL
#ifdef INSTRUMENTED
=======
  
  fprintf(gpu_stat_file,"%ld,",EA->getCurrentGeneration());
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
  DECLARE_TIME(gpu_eval);

  TIME_ST(gpu_eval);

  DECLARE_TIME(flat_trees);
  TIME_ST(flat_trees);
<<<<<<< HEAD
#endif
=======
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
  int index = 0;
  for( int i=0 ; i<popSize ; i++ ){
    indexes[i] = index;
    flattening_tree_rpn( ((IndividualImpl*)population[i])->root[0], progs, &index);
    progs[index++] = OP_RETURN;
  }
<<<<<<< HEAD
  /* TIME_END(flat_trees); */
#ifdef INSTRUMENTED
  currentStats.bLen = index;
#endif

#ifdef MULTI_GPU
  notify_gpus(progs, indexes, index, population,popSize, nbGPU);
#ifdef INSTRUMENTED
  TIME_END(gpu_eval);
#endif
=======
  TIME_END(flat_trees);

#ifdef MULTI_GPU

  notify_gpus(progs, indexes, index, population,popSize, nbGPU);
  TIME_END(gpu_eval);
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
#else
  CUDA_SAFE_CALL(cudaMemcpy( progs_k, progs, sizeof(float)*index, cudaMemcpyHostToDevice ));
  CUDA_SAFE_CALL(cudaMemcpy( indexes_k, indexes, sizeof(float)*popSize, cudaMemcpyHostToDevice ));

  // Here we will do the real GPU evaluation
<<<<<<< HEAD
#if 1
  EvaluatePostFixIndividuals_128_mgpu<<<popSize,128>>>( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength, results_k, hits_k, indexes_k,0,0);
#else
  int indivPerBlock = 4;
  dim3 numthreads;
  numthreads.x = 32;
  numthreads.y = indivPerBlock;
  fastEvaluatePostFixIndividuals_32_mgpu
    <<<popSize/indivPerBlock,numthreads,NUMTHREAD*sizeof(float)*2*indivPerBlock>>>
    ( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength,results_k, hits_k, indivPerBlock, indexes_k,0,0);
#endif
=======
  EvaluatePostFixIndividuals_128<<<popSize,128>>>( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength, results_k, hits_k, indexes_k);
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
  cudaThreadSynchronize();

  CUDA_SAFE_CALL(cudaMemcpy( hits, hits_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));
  CUDA_SAFE_CALL(cudaMemcpy( results, results_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));

<<<<<<< HEAD
#ifdef INSTRUMENTED
  TIME_END(gpu_eval);
#endif
#endif
#endif //ifdef GPUEVAL

#ifdef INSTRUMENTED
=======
  TIME_END(gpu_eval);

#endif

  /* for( int i=0 ; i<popSize ; i++ ){ */
  /*   //population[i]->fitness = results[i]; */
  /*   //population[i]->valid = true; */
  /* } */
  
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
  int err=0;
  DECLARE_TIME(cpu_eval);
  TIME_ST(cpu_eval);
#endif

#ifdef CPUEVAL
  for( int i=0 ; i<popSize ; i++ ){
    population[i]->evaluate();
    population[i]->valid = true;
<<<<<<< HEAD
    //printf("%d : %f | %f\n",i,population[i]->getFitness(),results[i]);
#ifdef CPUCMP
    if( fabs(results[i]-population[i]->getFitness())>population[i]->getFitness()*0.01){
=======
    //cout << "g " << population[i]->getFitness() << " : " << results[i] << endl;
    if( fabs(results[i]-population[i]->getFitness())>population[i]->getFitness()*0.1){
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
      err++;
    }
#endif
  }
#endif


#ifdef INSTRUMENTED
  TIME_END(cpu_eval);
<<<<<<< HEAD
  COMPUTE_TIME(flat_trees);
  COMPUTE_TIME(cpu_eval);
  COMPUTE_TIME(gpu_eval);
#endif

#ifdef GPUEVAL
  for( int i=0 ; i<popSize ; i++ ){
    population[i]->fitness = results[i];
    ((IndividualImpl*)population[i])->hits = hits[i];
    population[i]->valid = true;
  }
#endif

#ifdef INSTRUMENTED
  currentStats.cpu_eval_res = cpu_eval_res;
  currentStats.gpu_eval_res = gpu_eval_res;
  currentStats.flat_trees_res = flat_trees_res;
  currentStats.popSize = popSize;
  currentStats.err = err;
#endif
  TIME_END(global_eval);
  TIME_ACC(global_eval);

/*   fprintf(gpu_stat_file,",,%ld,",EA->getCurrentGeneration()); */
/*   DECLARE_TIME(gpu_eval); */
/*   TIME_ST(gpu_eval); */
/*   DECLARE_TIME(flat_trees); */
/*   TIME_ST(flat_trees); */
/*   int index = 0; */
/*   for( int i=0 ; i<popSize ; i++ ){ */
/*     indexes[i] = index; */
/*     flattening_tree_rpn( ((IndividualImpl*)population[i])->root[0], progs, &index); */
/*     progs[index++] = OP_RETURN; */
/*   } */
/*   TIME_END(flat_trees); */

/* #ifdef GPUEVAL */
/* #ifdef MULTI_GPU */
/*   notify_gpus(progs, indexes, index, population,popSize, nbGPU); */
/*   TIME_END(gpu_eval); */
/* #else */
/*   CUDA_SAFE_CALL(cudaMemcpy( progs_k, progs, sizeof(float)*index, cudaMemcpyHostToDevice )); */
/*   CUDA_SAFE_CALL(cudaMemcpy( indexes_k, indexes, sizeof(float)*popSize, cudaMemcpyHostToDevice )); */
/*   // Here we will do the real GPU evaluation */
/* #if GPUEVAL==128 */
/*   EvaluatePostFixIndividuals_128_mgpu<<<popSize,128>>>( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength, results_k, hits_k, indexes_k,0,0); */
/* #else */
/*   int indivPerBlock = GPUMINDIV; */
/*   dim3 numthreads;   */
/*   numthreads.x = 32;  */
/*   numthreads.y = indivPerBlock; */
/*   fastEvaluatePostFixIndividuals_32_mgpu<<<popSize/indivPerBlock,numthreads,NUMTHREAD*sizeof(float)*2*indivPerBlock>>> */
/*     ( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength,results_k, hits_k, indivPerBlock, indexes_k,0,0); */
/* #endif */
/*   cudaThreadSynchronize(); */
/*   CUDA_SAFE_CALL(cudaMemcpy( hits, hits_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost)); */
/*   CUDA_SAFE_CALL(cudaMemcpy( results, results_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost)); */
/*   TIME_END(gpu_eval); */
/* #endif */
/*   fprintf(gpu_stat_file,"%d,",index); */
/*   COMPUTE_TIME(flat_trees); */
/*   COMPUTE_TIME(gpu_eval); */
/*   fprintf(gpu_stat_file,"%ld.%06ld,",flat_trees_res.tv_sec,flat_trees_res.tv_usec); */
/*   fprintf(gpu_stat_file,"%ld.%06ld,",gpu_eval_res.tv_sec,gpu_eval_res.tv_usec); */
/* #endif */
/* #ifdef CPUEVAL   */
/*   int err=0; */
/*   DECLARE_TIME(cpu_eval); */
/*   TIME_ST(cpu_eval); */
/*   for( int i=0 ; i<popSize ; i++ ){ */
/*     population[i]->evaluate(); */
/*     population[i]->valid = true; */
/*     //cout << "g " << population[i]->getFitness() << " : " << results[i] << endl; */
/* #ifdef CPUCMP */
/*     if( fabs(results[i]-population[i]->getFitness())>population[i]->getFitness()*0.01){ */
/*       err++; */
/*     } */
/* #endif */
/*   } */
/*   TIME_END(cpu_eval); */
/*   COMPUTE_TIME(cpu_eval); */
/*   fprintf(gpu_stat_file,"%ld.%06ld,",cpu_eval_res.tv_sec,cpu_eval_res.tv_usec); */
/* #endif */


/* #ifdef CPUEVAL  */
/* #ifdef GPUEVAL */
/*   double speedUp = misc_tv_usec_l(&cpu_eval_res)/misc_tv_usec_l(&gpu_eval_res); */
/*   fprintf(gpu_stat_file,"%0.2f,%0.2f,",speedUp,(double)(popSize-err)/(double)popSize); */
/* #endif */
/* #endif */

/*   fprintf(gpu_stat_file,"%f,%f,",EA->population->currentAverageFitness,EA->population->currentSTDEV); */
/*   fprintf(gpu_stat_file,"\n"); */
/*   fflush(gpu_stat_file); */

/* #ifdef GPUEVAL */
/*   for( int i=0 ; i<popSize ; i++ ){ */
/*     population[i]->fitness = results[i]; */
/*     ((IndividualImpl*)population[i])->hits = hits[i]; */
/*     population[i]->valid = true; */
/*   } */
/* #endif */

=======

  COMPUTE_TIME(flat_trees);
  COMPUTE_TIME(cpu_eval);
  COMPUTE_TIME(gpu_eval);

  fprintf(gpu_stat_file,"%ld.%06ld,",flat_trees_res.tv_sec,flat_trees_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",cpu_eval_res.tv_sec,cpu_eval_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",gpu_eval_res.tv_sec,gpu_eval_res.tv_usec);

  double speedUp = misc_tv_usec_l(&cpu_eval_res)/misc_tv_usec_l(&gpu_eval_res);

  fprintf(gpu_stat_file,"%0.2f,%0.2f\n",speedUp,(double)(popSize-err)/(double)popSize);
  fflush(gpu_stat_file);
>>>>>>> 201de056936e25f50bb64f0c7af8873873c921a7
}
\end

\User classes :
GPNode {
  GPNode* children[MAX_ARITY];
  char opCode;
  int currentArity;
  double erc_value;
}

GenomeClass {
  GPNode* root[NB_TREES];
  int hits;
}
\end

\GenomeClass::display:
{
  os << this << " trees addr : " ;
  for( int i=0 ; i<NB_TREES ; i++ )
    os << Genome.root[i]<< "\t";
}
\end

\GenomeClass::initialiser :
{
  /**
     This is the standard ramped half-and-half method
     for creation of trees.
   */
  int id = EA->population->actualParentPopulationSize;  
  int seg = EA->population->parentPopulationSize/(TREE_DEPTH_MAX-TREE_DEPTH_MIN); 
  int currentDepth = TREE_DEPTH_MIN+id/seg;

  bool full;
  if( GROW_FULL_RATIO==0 ) full=true;
  else full = (id%seg)/(int)(seg*GROW_FULL_RATIO);

  //cout << seg << " " <<  currentDepth << " " << full ;
  for( int i=0 ; i<NB_TREES ; i++ ){
    Genome.root[i] = construction_method( constLen, totalLen , 1, currentDepth ,full, Genome.root[i] );
  }
  hits = 0;
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{

  printf("mutation called !!!!\n");
  // Cassical  mutation
  // select a node
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    int mutationPointChildId = 0;
    int mutationPointDepth = 0;
    GPNode* mutationPointParent = selectNode(Genome.root[tree], &mutationPointChildId, &mutationPointDepth);
    
    if( !mutationPointParent ){
      mutationPointParent = Genome.root[tree];
      mutationPointDepth = 0;
    }
    delete mutationPointParent->children[mutationPointChildId] ;
    mutationPointParent->children[mutationPointChildId] = NULL;
    mutationPointParent->children[mutationPointChildId] = 
      construction_method( constLen, totalLen , 1, MAX_MUTAT_DEPTH-mutationPointDepth ,0, mutationPointParent->children[mutationPointChildId]);
  }
  return NB_TREES;
}
\end

\GenomeClass::evaluator : // Returns the score
{
  /**
     Standard raw fitness, as in Koza's book.
     For symbolic regression, this is equal to 
     the standardized fitness.
   */
  double fitness = 0.;
  double fFit [NB_TREES];
  hits=0;
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    fFit[tree] = 0.;
    for( int i=0 ; i<fitnessCasesSetLength ; i++ ){
      float evolvedValue = recEvale(Genome.root[tree],inputs[i]);
      float result = fabs(evolvedValue-outputs[i][tree]);
      fFit[tree] += result;
      if (result <= HIT_LEVEL)
	hits++;
    }
    fitness += fFit[tree];
  } 
  Genome.valid = true;
  Genome.fitness = fitness;


  return fitness;
}
\end

\User Makefile options: 

CXXFLAGS+=-I/usr/local/cuda/common/inc/ -I/usr/local/cuda/include/
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 1       // NB_GEN
  Time limit: 0 		  // In seconds, 0 to deactivate
  Population size : 4096          //POP_SIZE
  Offspring size : 4096           // 40% 
  Mutation probability : 0       // MUT_PROB
  Crossover probability : 0.9     // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1

  Print stats:1				//Default: 1
  Generate cvs stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
