/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
__________________________________________________________*/

\User declarations :
//#include <gsl/gsl_rng.h>
#include <assert.h>
#include <errno.h>
#include <sstream>
#include <math.h>


#include <cutil.h>
#include <cuda_runtime_api.h>
#define TIMING 
#include <timing.h>

#define  OPERAND 0


// number of input variables
#define VAR_LEN 1

// Here, some well known parameters for GP.
#define MAX_ARITY 2          // maximum arrity for GP nodes
#define NB_TREES 1           // number of co-evolved trees
#define TREE_DEPTH_MIN 8     // minimum size of (initial) trees (included)
#define TREE_DEPTH_MAX 9     // maximum size of (initial) trees (excluded)
#define GROW_FULL_RATIO 0.5  // ratio between grow and full construction method
#define DIV_ERR_VALUE 1      // Returned value, in case of non defined input value
#define MAX_XOVER_DEPTH 17
#define MAX_MUTAT_DEPTH 17

// Here, some GPGPGPU parameters
#define MAX_PROGS_SIZE 20000000

float** inputs;
float** outputs;

float* input_k;
float* output_k;

float* progs     = NULL;
float* progs_k   = NULL;

int* indexes     = NULL;
int* indexes_k   = NULL;

int* hits      = NULL;
int* hits_k    = NULL;
float* results   = NULL;
float* results_k = NULL;


int fitnessCasesSetLength;

/** For the sake of simplicity, constant operators become first in the function set
    Koza defines 2 operator sets, one for constants, another for function.

    @TODO
    Terminal variables could be encoded differently, for example using one opCode for every
    variable, and another field to encode the id of the variable (what about the likelyhood of having 
    each variable (this sould divide by the number of variables)
*/


#define OP 1
#if 0
enum OPCODE               { OP_ERC, OP_W, OP_X, OP_Y, OP_Z, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OP_SIN, OP_COS, OP_EXP, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "x" , "y" , "z" , "*"   , "+"   , "-"   , "/"   , "sin" , "cos" , "exp" };
int opArrity[] =          { 0     , 0   , 0   , 0   , 0   , 2     , 2     , 2     , 2     , 1     , 1     , 1     };
int constLen = 5;
int totalLen = OPCODE_SIZE;
#else
enum OPCODE               { OP_ERC, OP_W, OP_MUL, OP_ADD, OP_SUB,  OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "w" , "*"   , "+"   , "-"   ,  "/"};
int opArrity[] =          { 0     ,  0   , 2     , 2     , 2    ,  2  };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#endif

#include "tgp_regressionEval.cu"

\end

\User functions:
#define MILLION_I 1000000
/* Convert a timeval to microseconds as a long */
long misc_tv_usec_l(struct timeval *t){
  return ((long) t->tv_sec * MILLION_I) + t->tv_usec;
}


/** This function allows one to load .csv file for 1 input variables.T he file must start with the number
    of fitness cases, then it has to contain every inputs values, finally outputs values for each point : 
    x[0,1], x[0,2], ..., x[0,n], f(x[0])
    x[1,1], x[1,2], ..., x[1,n], f(x[1])
    ...
    x[m,1], x[m,2], ..., x[m,n], f(x[m])

    This function allocates inputs and outputs wrt the size written in the file*/
int load_data(float*** inputs, float*** outputs, string filename){
  int i;
  FILE* file = fopen(filename.c_str(),"r");
  int loaded_size;
  int match = 0;
  int variable;

  if( !file ){
    fprintf(stderr,"ERROR : input file (%s) cannot be opened\n",filename.c_str());
    exit(-1);
  }

  match = fscanf(file,"%d\n",&loaded_size);
  assert(match==1);

  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float**)malloc(sizeof(**outputs)*loaded_size);
  
  for( i=0 ; i<loaded_size ; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*VAR_LEN);
    for( variable=0 ; variable<VAR_LEN ; variable++ ){   
      match = fscanf(file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    (*outputs)[i] = (float*)malloc(sizeof(**outputs)*NB_TREES);
    for( int output_vals = 0 ; output_vals<NB_TREES ; output_vals++ ){
      match = fscanf(file,"%f,\n",(*outputs)[i]+output_vals);
      assert(match==1);
    }
  }
  fclose(file);
  return loaded_size;
}

#define NB_FITNESS_CASES 128
#define POLY(x) x*x*x*x*x*x-2*x*x*x*x+x*x

int generateData(float*** inputs, float*** outputs){
  int i=0;

  (*inputs) = (float**)malloc(sizeof(**inputs)*NB_FITNESS_CASES);
  (*outputs) = (float**)malloc(sizeof(**outputs)*NB_FITNESS_CASES);

  for( i=0 ; i<NB_FITNESS_CASES ; i++ ){
    (*inputs)[i]=(float*)malloc(sizeof(***inputs));
    (*outputs)[i]=(float*)malloc(sizeof(***outputs));
    float x = random(-1.0,1.0);
    (*inputs)[i][0] = x;
    (*outputs)[i][0] = POLY(x);
  }

  return NB_FITNESS_CASES;
}


void free_data(){

  for( int i=0 ; i<fitnessCasesSetLength ;i++ )
    free( inputs[i] );
  for( int i=0 ; i<NB_TREES ; i++ )
    free( outputs[i] );
  free( inputs );
  free( outputs );
}

/**
    Recursive construction method for trees.
    Koza construction methods. Function set has to be ordered,
    with first every terminal nodes and then non-terminal.

    @arg constLen : length of terminal function set.
    @arg totalLen : length of the function set (non-terminal+terminal)
    @arg currentDepth : depth of the origin (sould always be 0, when the function
    is directly call)
    @arg maxDepth : The maximum depth of the resulting tree.
    @arg full : whether the construction method used has to be full (from koza's book)
                Otherwise, it will use grow method (defined in the same book).
 
    @return : pointer to the root node of the resulting sub tree
 */
GPNode* construction_method( const int constLen, const int totalLen , const int currentDepth,
			     const int maxDepth, const bool full, GPNode* parentPtr){
  GPNode* node = new GPNode();
  // first select the opCode for the current Node.
  if( full ){
    if( currentDepth<maxDepth ) node->opCode = random(constLen,totalLen);
    else node->opCode = random(0, constLen);
  }
  else{
    if( currentDepth<maxDepth ) node->opCode = random(0, totalLen);
    else node->opCode = random(0, constLen);
  }
 
  int arity = opArrity[(int)node->opCode];
  node->currentArity = arity;

  // construct children (if any)
  for( int i=0 ; i<arity ; i++ )
    node->children[i] = construction_method(constLen, totalLen, currentDepth+1, maxDepth, full, node);
  
  // affect null to other array cells (if any)
  for( int i=arity ; i<MAX_ARITY ; i++ )
    node->children[i] = NULL;

  if( node->opCode==OP_ERC ){
    node->erc_value = random(0.,1.);
  }

  return node;
}

/**
   This function handles printing of tree.
   Every node is identify by its address, in memory,
   and labeled by the actual opCode.

   On our architecture (64bits, ubuntu 8.04 and gcc-4.3.2)
   the long int variable is sufficient to store the address
   without any warning.
 */
void toDotFile_r(GPNode* root, FILE* outputFile){
  if( root->opCode==OP_ERC )
    fprintf(outputFile," %ld [label=\"%s : %f\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str(),
	    root->erc_value);
 else
   fprintf(outputFile," %ld [label=\"%s\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str());
  
  for( int i=0 ; i<root->currentArity ; i++ ){
    if( root->children[i] ){
      fprintf(outputFile,"%ld -> %ld;\n", (long int)root, (long int)root->children[i]);
      toDotFile_r( root->children[i] , outputFile);
    }
  }
}

/**
   This function prints a tree in dot (graphviz format).
   This is the entry point for the print operation. (see toDotFile_r,
   for the actual function)

   @arg root : set of trees, same type than in a individual.
   @arg baseFileName : base of filename for the output file.
   @arg treeId : the id of the tree to print, in the given set.
 */
void toDotFile(GPNode* root, const char* baseFileName, int treeId){
  std::ostringstream oss;
  oss << baseFileName << "-" << treeId << ".gv";

  FILE* outputFile = fopen(oss.str().c_str(),"w");
  if( !outputFile ){
    perror("Opening file for outputing dot representation ");
    exit(-1);
  }

  fprintf(outputFile,"digraph trees {\n");
  if(root)
    toDotFile_r( root, outputFile);
  fprintf(outputFile,"}\n");
  fclose(outputFile);
}


/**
   Compute the maximum depth of a tree, rooted on root.

   @arg root : root of the tree
   @return : depth of current tree rooted on root
 */
int depthOfTree(GPNode* root){
  int depth = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    int d = depthOfTree(root->children[i]);
    if( d>=depth ) depth = d;
  }
  return depth+1;
}


/**
   Recursively evaluate tree for given inputs
   
 */
float recEvale(GPNode* root, float* inputs){
  if( root->currentArity==2 ){
    float a=recEvale(root->children[0],inputs);
    float b=recEvale(root->children[1],inputs);
    switch( root->opCode ){
    case OP_MUL: return a*b;
    case OP_ADD: return a+b;
    case OP_SUB: return a-b;
    case OP_DIV:
      if( !b ) return DIV_ERR_VALUE;
      else return a/b;
    default:
      fprintf(stderr,"unknown binary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else if( root->currentArity==1 ){
    float a=recEvale(root->children[0],inputs);
    switch( root->opCode ){
/*     case OP_SIN: return sin(a); */
/*     case OP_COS: return cos(a); */
/*     case OP_EXP: return exp(a); */
    default:
      fprintf(stderr,"unknown unary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else
    switch( root->opCode ){
    case OP_ERC: return root->erc_value;
    case OP_W: return inputs[0];

#if OP>1
    case OP_X: return inputs[1];
#endif

#if OP>2
    case OP_Y: return inputs[2];
#endif

#if OP>3
    case OP_Z: return inputs[3];
#endif
    default:
      fprintf(stderr,"unknown terminal opcode %d\n",root->opCode);
      exit(-1);
    }
}


/**
   Fill the collection array with GPNode located at goalDepth

   @arg goalDepth: level from which GPNode are collected
   @arg collection: an empty, allocated array
 */
int collectNodesDepth(const int goalDepth, GPNode** collection, int collected, int currentDepth, GPNode* root){

  if( currentDepth>=goalDepth ){
    collection[collected] = root;
    return collected+1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      collected=collectNodesDepth(goalDepth, collection, collected, currentDepth+1, root->children[i]);
    }
    return collected;
  }
}


/**
   Pick a node in a tree. It first pick a depth and then, it pick a
   node amongst nodes at this depth. It returns the parent node,
   and by pointer, the childId of the choosen child.

   @arg root : the root node of the tree, amongt which we have to choose the node
   @arg chilId : pointer to an allocated int, children position of the choosen node will be stored here
   @arg depth : pointer to an allocated int, will contain the choosen depth.

   @return : return the address of the parent of the choosen node. Return null if the root node has been choosen
 */
GPNode* selectNode( GPNode* root, int* childId, int* depth){
  
  int xoverDepth = random(0,depthOfTree(root));
  (*depth) = xoverDepth;
  
  GPNode** dNodes;
  int collected;

  if(xoverDepth!=0){
    dNodes = new GPNode*[1<<(xoverDepth-1)];
    collected = collectNodesDepth(xoverDepth-1,dNodes,0,0,root);
  }
  else{
    return NULL;
  }
  int stockPointCount=0;
  for( int i=0 ; i<collected; i++ ){
    stockPointCount+=dNodes[i]->currentArity;
  }

  int reminderP = 0, parentIndexP = 0;

  int xoverP = random(0,stockPointCount);
  for( int i=0 ; ; )
    if( (i+dNodes[parentIndexP]->currentArity)>xoverP ){
      reminderP = xoverP-i;
      break;
    }
    else i+=dNodes[parentIndexP++]->currentArity;
  
  *childId = reminderP;
  //cout << "d of x : " << xoverDepth << "/" << depthOfTree(root)<< " n : "<< xoverP << endl;
  GPNode* ret = dNodes[parentIndexP];
  delete[] dNodes;
  return ret;
}
			 
void flattenDatas( float** inputs, int length, int width, float** flat_inputs){
  (*flat_inputs)=(float*)malloc(sizeof(float)*length*width);
  for( int i=0 ; i<length ; i++ ){
    for( int j=0 ; j<width ; j++ ){
      (*flat_inputs)[i*width+j] = inputs[i][j];
    }
  }
}



/**
   Send input and output data on the GPU memory.
   Allocate
 */
void initialDataToGPU(float* input_f, int length_input, float* output_f, int length_output){
  // allocate and copy input/output arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)(&input_k),sizeof(float)*length_input));
  CUDA_SAFE_CALL(cudaMalloc((void**)(&output_k),sizeof(float)*length_output));
  CUDA_SAFE_CALL(cudaMemcpy(input_k,input_f,sizeof(float)*length_input,cudaMemcpyHostToDevice));
  CUDA_SAFE_CALL(cudaMemcpy(output_k,output_f,sizeof(float)*length_input,cudaMemcpyHostToDevice));

  // allocate indexes and programs arrays
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);
  CUDA_SAFE_CALL(cudaMalloc((void**)&indexes_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL( cudaMalloc((void**)&progs_k,sizeof(*progs_k)*MAX_PROGS_SIZE));

  // allocate hits and results arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)&results_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL(cudaMalloc((void**)&hits_k,sizeof(*indexes_k)*maxPopSize));
}

/**
   Free gpu memory from the input and ouput arrays.
 */
void free_gpu(){
  cudaFree(input_k);
  cudaFree(output_k);
  cudaFree(progs_k);
  cudaFree(indexes_k);
  cout << "GPU freed" << endl;
}


int flattening_tree_rpn( GPNode* root, float* buf, int* index){
  int i;

  for( i=0 ; i<root->currentArity ; i++ ){
    flattening_tree_rpn(root->children[i],buf,index);
  }
  if( (*index)+2>MAX_PROGS_SIZE )return 0;
  buf[(*index)++] = root->opCode;
  if( root->opCode == OP_ERC ) buf[(*index)++] = root->erc_value;
  return 1;
}

int enumTreeNodes(GPNode* root){
  int nbNode = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    nbNode+=enumTreeNodes(root->children[i]);
  }
  return nbNode+1;
}


GPNode* pickNthNode(GPNode* root, int N, int* childId){
  
  GPNode* stack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  GPNode* parentStack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  int stackPointer = 0;

  parentStack[stackPointer] = NULL;
  stack[stackPointer++] = root;

  for( int i=0 ; i<N ; i++ ){
    GPNode* currentNode = stack[stackPointer-1];
    //cout <<  currentNode << endl;
    stackPointer--;
    for( int j=currentNode->currentArity ; j>0 ; j--){
      parentStack[stackPointer] = currentNode;
      stack[stackPointer++] = currentNode->children[j-1];
    }
  }

  //assert(stackPointer>0);
  if( stackPointer )
    stackPointer--;
  
  //cout << "f : \n\t n :" << stack[stackPointer ] << "\n\t p :" << parentStack[stackPointer] << " cId : " << (*childId) << endl;
  
  for( int i=0 ; i<parentStack[stackPointer]->currentArity ; i++ ){
    if( parentStack[stackPointer]->children[i]==stack[stackPointer] ){
      (*childId)=i;
      break;
    }
  }
  

  return parentStack[stackPointer];
}


int depthOfNode(GPNode* root, GPNode* node){

  if( root==node ){
    return 1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      int depth = depthOfNode(root->children[i],node);
      if( depth )
	return depth+1;
    }
    return 0;
  }
}

void simpleCrossOver(IndividualImpl& p1, IndividualImpl& p2, IndividualImpl& c){
  int depthP1 = depthOfTree(p1.root[0]);
  int depthP2 = depthOfTree(p2.root[0]);

  int nbNodeP1 = enumTreeNodes(p1.root[0]);
  int nbNodeP2 = enumTreeNodes(p2.root[0]);

  int stockPointChildId=0;
  int graftPointChildId=0;


  bool stockCouldBeTerminal = tossCoin(0.9);
  bool graftCouldBeTerminal = tossCoin(0.9);


  int childrenDepth, Np1, Np2;
  GPNode* stockParentNode ;
  GPNode* graftParentNode ;

  do{
    if( stockCouldBeTerminal ) Np1 = random(0,nbNodeP1);
    else Np1 = random(0,nbNodeP1-1);
    if( graftCouldBeTerminal ) Np2 = random(0,nbNodeP2);
    else Np2 = random(0,nbNodeP2-1);
    
    if( Np1 ) stockParentNode = pickNthNode(c.root[0], MIN(Np1,nbNodeP1) ,&stockPointChildId);
    if( Np2 ) graftParentNode = pickNthNode(p2.root[0], MIN(Np2,nbNodeP1) ,&graftPointChildId);
    
    if( Np2 && Np1)
      childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthOfTree(graftParentNode->children[graftPointChildId]);
    else if( Np1 ) childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthP1;
    else if( Np2 ) childrenDepth = depthOfTree(graftParentNode->children[graftPointChildId]);
    else childrenDepth = depthP2;
    
  }while( childrenDepth>MAX_XOVER_DEPTH );
  
  if( Np1 && Np2 ){
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }
  else if( Np1 ){ // && Np2==NULL
    // We want to use the root of the parent 2 as graft
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = p2.root[0];
    p2.root[0] = NULL;
  }else if( Np2 ){ // && Np1==NULL
    // We want to use the root of the parent 1 as stock
    delete c.root[0];
    c.root[0] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }else{
    // We want to switch root nodes between parents
    delete c.root[0];
    c.root[0]  = p2.root[0];
    p2.root[0] = NULL;
  }

  toDotFile(c.root[0],"out/xover/cf",0);
}

\end



\Before everything else function:
{
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);

  // load data from csv file.
  cout<<"Before everything else function called "<<endl;
  //fitnessCasesSetLength = load_data(&inputs,&outputs,"data_koza_sextic.csv");
  fitnessCasesSetLength = generateData(&inputs,&outputs);
  cout << "number of point in fitness cases set : " << fitnessCasesSetLength << endl;

  float* inputs_f = NULL;
  float* outputs_f = NULL;

  flattenDatas(inputs,fitnessCasesSetLength,VAR_LEN,&inputs_f);
  flattenDatas(outputs,fitnessCasesSetLength,NB_TREES,&outputs_f);

  indexes = new int[maxPopSize];
  hits    = new int[maxPopSize];
  results = new float[maxPopSize];
  progs   = new float[MAX_PROGS_SIZE];
  
  INSTEAD_EVAL_STEP=true;
  //INSTEAD_EVAL_STEP=false;
  // Adding another stopping, as we are minimizing, the goal is 0
  //CGoalCriterion* gc = new CGoalCriterion(0,true);
  //EA->stoppingCriteria.push_back(gc);


  // Here starts the CUDA parts
  cudaSetDevice(1); // on GTX295 ;) we want to use the second card for computation
  initialDataToGPU(inputs_f, fitnessCasesSetLength*VAR_LEN, outputs_f, fitnessCasesSetLength*NB_TREES);

  cout << "seed is : " << EA->params->seed << endl;
}
\end

\After everything else function:
{
  // write tree of every individuals in a separate file.
  for( unsigned int i=0 ; i<population->actualParentPopulationSize ; i++ ){
    std::ostringstream oss;
    oss << "out/indiv-" << i << "-trees" ;
    toDotFile( ((IndividualImpl*)population->parents[i])->root[0],oss.str().c_str(),0);
  }

  // not sure that the population is sorted now. So lets do another time (or check in the code;))
  // and dump the best individual in a graphviz file.
  population->sortParentPopulation();
  toDotFile( ((IndividualImpl*)population->parents[0])->root[0], "best-of-run",0);
  
  // delete some global arrays
  delete[] indexes; delete[] hits;
  delete[] results; delete[] progs;
  
  free_gpu();
  free_data();
}
\end

\At the beginning of each generation function:
  //cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\Instead evaluation function:
{
  DECLARE_TIME(gpu_eval);
  TIME_ST(gpu_eval);
      
  int index = 0;
  for( int i=0 ; i<popSize ; i++ ){
    indexes[i] = index;
    flattening_tree_rpn( ((IndividualImpl*)population[i])->root[0], progs, &index);
    progs[index++] = OP_RETURN;
  }

  CUDA_SAFE_CALL(cudaMemcpy( progs_k, progs, sizeof(float)*index, cudaMemcpyHostToDevice ));
  CUDA_SAFE_CALL(cudaMemcpy( indexes_k, indexes, sizeof(float)*popSize, cudaMemcpyHostToDevice ));

  // Here we will do the real GPU evaluation
  EvaluatePostFixIndividuals_128<<<popSize,128>>>( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength, results_k, hits_k, indexes_k);
  TIME_END(gpu_eval);


  CUDA_SAFE_CALL(cudaMemcpy( hits, hits_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));
  CUDA_SAFE_CALL(cudaMemcpy( results, results_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));


  for( int i=0 ; i<popSize ; i++ ){
    //population[i]->fitness = results[i];
    //population[i]->valid = true;
  }
  
  int err=0;
  DECLARE_TIME(cpu_eval);
  TIME_ST(cpu_eval);
  for( int i=0 ; i<popSize ; i++ ){
    population[i]->evaluate();
    population[i]->valid = true;
    if( fabs(results[i]-population[i]->getFitness())>population[i]->getFitness()*0.05){
      err++;
      /* toDotFile(((IndividualImpl*)population[i])->root[0],"error",0); */
      
      /* int k = indexes[i]; */
      /* while( progs[k]!=OP_RETURN ){ */
      /* 	cout << progs[k++] << ", " ; */
      /* } */
      /* cout << endl; */
      /* exit(-1); */
      //printf("err %d = %f | %f\n",i,results[i],population[i]->getFitness());
    }
  }
  TIME_END(cpu_eval);
  //SHOW_TIME(cpu_eval);
  SHOW_TIME_FLAT(cpu_eval);
  cout << "," ;
  SHOW_TIME_FLAT(gpu_eval);
  double speedUp = misc_tv_usec_l(&cpu_eval_res)/misc_tv_usec_l(&gpu_eval_res);
  cout << "," << speedUp<< endl;
  cout << "Error : " << err << "/" << popSize << endl;
}
\end

\User classes :
GPNode {
  GPNode* children[MAX_ARITY];
  char opCode;
  int currentArity;
  double erc_value;
}

GenomeClass {
  GPNode* root[NB_TREES];
}
\end

\GenomeClass::display:
{
  os << this << " trees addr : " ;
  for( int i=0 ; i<NB_TREES ; i++ )
    os << Genome.root[i]<< "\t";
}
\end

\GenomeClass::initialiser :
{
  /**
     This is the standard ramped half-and-half method
     for creation of trees.
   */
  int id = EA->population->actualParentPopulationSize;  
  int seg = EA->population->parentPopulationSize/(TREE_DEPTH_MAX-TREE_DEPTH_MIN); 
  int currentDepth = TREE_DEPTH_MIN+id/seg;

  bool full;
  if( GROW_FULL_RATIO==0 ) full=true;
  else full = (id%seg)/(int)(seg*GROW_FULL_RATIO);

  //cout << seg << " " <<  currentDepth << " " << full ;
  for( int i=0 ; i<NB_TREES ; i++ ){
    Genome.root[i] = construction_method( constLen, totalLen , 1, currentDepth ,full, Genome.root[i] );
  }
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{

  // Cassical  mutation
  // select a node
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    int mutationPointChildId = 0;
    int mutationPointDepth = 0;
    toDotFile( Genome.root[tree], "out/mutation/p", tree);
    GPNode* mutationPointParent = selectNode(Genome.root[tree], &mutationPointChildId, &mutationPointDepth);
    
    
    if( !mutationPointParent ){
      mutationPointParent = Genome.root[tree];
      mutationPointDepth = 0;
    }
    toDotFile( Genome.root[tree], "out/mutation/p", tree);
    delete mutationPointParent->children[mutationPointChildId] ;
    mutationPointParent->children[mutationPointChildId] = NULL;
    mutationPointParent->children[mutationPointChildId] = 
      construction_method( constLen, totalLen , 1, MAX_MUTAT_DEPTH-mutationPointDepth ,0, mutationPointParent->children[mutationPointChildId]);
    toDotFile( Genome.root[tree], "out/mutation/f", tree);
  }
  return NB_TREES;
}
\end

\GenomeClass::evaluator : // Returns the score
{
  /**
     Standard raw fitness, as in Koza's book.
     For symbolic regression, this is equal to 
     the standardized fitness.
   */
  double fitness = 0.;
  double fFit [NB_TREES];
  
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    fFit[tree] = 0.;
    for( int i=0 ; i<fitnessCasesSetLength ; i++ ){
      float evolvedValue = recEvale(Genome.root[tree],inputs[i]);
      fFit[tree] += fabs(evolvedValue-outputs[i][tree]);
    }
    fitness += fFit[tree];
  } 
  Genome.valid = true;
  Genome.fitness = fitness;
  return fitness;
}
\end

\User Makefile options: 

CXXFLAGS+=-I/usr/local/cuda/common/inc/ -I/usr/local/cuda/include/
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 1       // NB_GEN
  Time limit: 0 		  // In seconds, 0 to deactivate
  Population size : 10	          //POP_SIZE
  Offspring size : 10              // 40% 
  Mutation probability : 0        // MUT_PROB
  Crossover probability : 0.9       // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1

  Print stats:1				//Default: 1
  Generate cvs stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
