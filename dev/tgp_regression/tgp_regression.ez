/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
__________________________________________________________*/

\User declarations :
//#include <gsl/gsl_rng.h>
#include <assert.h>
#include <errno.h>
#include <sstream>
#define  OPERAND 0


// number of input variables
#define VAR_LEN 4 

// Here, some well known parameters for GP.
#define MAX_ARITY 3          // maximum arrity for GP nodes
#define NB_TREES 2           // number of co-evolved trees
#define TREE_DEPTH_MIN 4     // minimum size of (initial) trees (included)
#define TREE_DEPTH_MAX 9     // maximum size of (initial) trees (excluded)
#define GROW_FULL_RATIO 0.5  // ratio between grow and full construction method

float** inputs;
float* outputs;
float fitnessCasesSetLength;

/* For the sake of simplicity, constant operators become first in the function set
   Koza defines 2 operator sets, one for constants, another for function.
*/
enum OPCODE               { OP_ERC, OP_LD_INPUT, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OP_SIN, OP_COS, OP_EXP, OPCODE_SIZE };
const string opCodeName[]={ "erc" , "input"    , "*"   , "+"   , "-"   , "/"   , "sin" , "cos" , "exp" };
int opArrity[] =          { 0     , 0          , 2     , 2     , 2     , 2     , 1     , 1     , 1     };
int constLen = 2;
int totalLen = OPCODE_SIZE;
\end

\User functions:
/** This function allows one to load .csv file for 1 input variables.T he file must start with the number
    of fitness cases, then it has to contain every inputs values, finally outputs values for each point : 
    x[0,1], x[0,2], ..., x[0,n], f(x[0])
    x[1,1], x[1,2], ..., x[1,n], f(x[1])
    ...
    x[m,1], x[m,2], ..., x[m,n], f(x[m])

    This function allocates inputs and outputs wrt the size written in the file*/
int load_data(float*** inputs, float** outputs, string filename){
  int i;
  FILE* file = fopen(filename.c_str(),"r");
  int loaded_size;
  int match = 0;
  int variable;

  if( !file ){
    fprintf(stderr,"ERROR : input file (%s) cannot be opened\n",filename.c_str());
    exit(-1);
  }

  match = fscanf(file,"%d\n",&loaded_size);
  assert(match==1);

  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float*)malloc(sizeof(**outputs)*loaded_size);
  
  for( i=0 ; i<loaded_size ; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*VAR_LEN);
    for( variable=0 ; variable<VAR_LEN ; variable++ ){   
      match = fscanf(file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    match = fscanf(file,"%f\n",(*outputs)+i);
    assert(match==1);
  }
  return loaded_size;
}

/** Recursive construction method for trees.
    Koza construction methods. Function set has to be ordered,
    with first every terminal nodes and then non-terminal.

    @arg constLen : length of terminal function set.
    @arg totalLen : length of the function set (non-terminal+terminal)
    @arg currentDepth : depth of the origin (sould always be 0, when the function
    is directly call)
    @arg maxDepth : The maximum depth of the resulting tree.
    @arg full : whether the construction method used has to be full (from koza's book)
                Otherwise, it will use grow method (defined in the same book).
 
    @return : pointer to the root node of the resulting sub tree
 */
GPNode* construction_method( const int constLen, const int totalLen , int currentDepth,
			     const int maxDepth, const bool full){
  GPNode* node = new GPNode();
  
  // first select the opCode for the current Node.
  if( full )
    if( currentDepth<maxDepth ) node->opCode = random(constLen,totalLen);
    else node->opCode = random(0, constLen);
  else
    if( currentDepth<maxDepth ) node->opCode = random(0, totalLen);
    else node->opCode = random(0, constLen);
 
  int arity = opArrity[(int)node->opCode];
  node->currentArity = arity;

  // construct children (if any)
  for( int i=0 ; i<arity ; i++ )
    node->children[i] = construction_method(constLen, totalLen, currentDepth+1, maxDepth, full );
  
  // affect null to other array cells (if any)
  for( int i=arity ; i<MAX_ARITY ; i++ )
    node->children[i] = NULL;

  return node;
}

/**
   This function handles printing of tree.
   Every node is identify by its address, in memory,
   and labeled by the actual opCode.

   On our architecture (64bits, ubuntu 8.04 and gcc-4.3.2)
   the long int variable is sufficient to store the address
   without any warning.
 */
void toDotFile_r(GPNode* root, FILE* outputFile){
  fprintf(outputFile," %ld [label=\"%s\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str());
  for( int i=0 ; i<root->currentArity ; i++ ){
    fprintf(outputFile,"%ld -> %ld;\n", (long int)root, (long int)root->children[i]);
    toDotFile_r( root->children[i] , outputFile);
  }
}

/**
   This function prints a tree in dot (graphviz format).
   This is the entry point for the print operation. (see toDotFile_r,
   for the actual function)

   @arg root : set of trees, same type than in a individual.
   @arg baseFileName : base of filename for the output file.
   @arg treeId : the id of the tree to print, in the given set.
 */
void toDotFile(GPNode* root[NB_TREES], const char* baseFileName, int treeId){
  std::ostringstream oss;
  oss << baseFileName << "-" << treeId << ".gv";

  FILE* outputFile = fopen(oss.str().c_str(),"w");
  if( !outputFile ){
    perror("Opening file for outputing dot representation ");
    exit(-1);
  }

  fprintf(outputFile,"digraph trees {\n");
  toDotFile_r( root[treeId], outputFile);
  fprintf(outputFile,"}\n");
}
\end



\Before everything else function:
{
  int fitnessCasesSetLength;
  cout<<"Before everything else function called "<<endl;
  fitnessCasesSetLength = load_data(&inputs,&outputs,"data.csv");

  //full_method( constLen, totalLen, 0, 15 );
}
\end

\After everything else function:
{
  for( unsigned int i=0 ; i<population->actualParentPopulationSize ; i++ ){
    std::ostringstream oss;
    oss << "out/indiv-" << i << "-trees" ;
      toDotFile( ((IndividualImpl*)population->parents[i])->root,oss.str().c_str(),0);
      toDotFile( ((IndividualImpl*)population->parents[i])->root,oss.str().c_str(),1);
  }
}
\end

\At the beginning of each generation function:
  //cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\User classes :
GPNode {
  GPNode* children[MAX_ARITY];
  char opCode;
  int currentArity;
}

GenomeClass { 
  GPNode* root[NB_TREES];
}
\end

\GenomeClass::display:
{
  os << this << " trees addr : " ;
  for( int i=0 ; i<NB_TREES ; i++ )
    os << Genome.root[i]<< "\t";
}
\end

\GenomeClass::initialiser :
{

  
  int id = EA->population->actualParentPopulationSize;
  int currentDepth;

  
  int seg = EA->population->parentPopulationSize/(TREE_DEPTH_MAX-TREE_DEPTH_MIN);
  cout << id << " "<< seg<< " " << id/seg  << " " << TREE_DEPTH_MIN+id/seg<< endl;
  
  for( int i=0 ; i<NB_TREES ; i++ ){
    Genome.root[i] = construction_method( constLen, totalLen , 0, 6,false);
  }
}
\end

\GenomeClass::crossover :
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  return 0;
}
\end

\GenomeClass::evaluator : // Returns the score
{
  return 0;
}
\end

\User Makefile options: 
CPPFLAGS+=
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 1     	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 10			//POP_SIZE
  Offspring size : 0 // 40% 
  Mutation probability : 1       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 2.0
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			//Weak or Strong
  Elite: 0

  Print stats:1				//Default: 1
  Generate cvs stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
	
