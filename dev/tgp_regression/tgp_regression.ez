/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
__________________________________________________________*/

\User declarations :
//#include <gsl/gsl_rng.h>
#include <assert.h>
#include <errno.h>
#include <sstream>
#include <math.h>
#define  OPERAND 0


// number of input variables
#define VAR_LEN 1

// Here, some well known parameters for GP.
#define MAX_ARITY 2          // maximum arrity for GP nodes
#define NB_TREES 1           // number of co-evolved trees
#define TREE_DEPTH_MIN 4     // minimum size of (initial) trees (included)
#define TREE_DEPTH_MAX 5     // maximum size of (initial) trees (excluded)
#define GROW_FULL_RATIO 0.5  // ratio between grow and full construction method
#define DIV_ERR_VALUE 1      // Returned value, in case of non defined input value
#define MAX_XOVER_DEPTH 4
#define MAX_MUTAT_DEPTH 4

float** inputs;
float** outputs;
int fitnessCasesSetLength;

/** For the sake of simplicity, constant operators become first in the function set
    Koza defines 2 operator sets, one for constants, another for function.

    @TODO
    Terminal variables could be encoded differently, for example using one opCode for every
    variable, and another field to encode the id of the variable (what about the likelyhood of having 
    each variable (this sould divide by the number of variables)
*/

#if 0
enum OPCODE               { OP_ERC, OP_W, OP_X, OP_Y, OP_Z, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OP_SIN, OP_COS, OP_EXP, OPCODE_SIZE };
const string opCodeName[]={ "erc" , "w" , "x" , "y" , "z" , "*"   , "+"   , "-"   , "/"   , "sin" , "cos" , "exp" };
int opArrity[] =          { 0     , 0   , 0   , 0   , 0   , 2     , 2     , 2     , 2     , 1     , 1     , 1     };
int constLen = 5;
int totalLen = OPCODE_SIZE;
#else
enum OPCODE               { OP_ERC, OP_W, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OPCODE_SIZE };
const string opCodeName[]={ "erc" , "w" , "*"   , "+"   , "-"   , "/"   };
int opArrity[] =          { 0     ,  0   , 2     , 2     , 2     , 2    };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#endif
\end

\User functions:
/** This function allows one to load .csv file for 1 input variables.T he file must start with the number
    of fitness cases, then it has to contain every inputs values, finally outputs values for each point : 
    x[0,1], x[0,2], ..., x[0,n], f(x[0])
    x[1,1], x[1,2], ..., x[1,n], f(x[1])
    ...
    x[m,1], x[m,2], ..., x[m,n], f(x[m])

    This function allocates inputs and outputs wrt the size written in the file*/
int load_data(float*** inputs, float*** outputs, string filename){
  int i;
  FILE* file = fopen(filename.c_str(),"r");
  int loaded_size;
  int match = 0;
  int variable;

  if( !file ){
    fprintf(stderr,"ERROR : input file (%s) cannot be opened\n",filename.c_str());
    exit(-1);
  }

  match = fscanf(file,"%d\n",&loaded_size);
  assert(match==1);

  (*inputs) = (float**)malloc(sizeof(**inputs)*loaded_size);
  (*outputs) = (float**)malloc(sizeof(**outputs)*loaded_size);
  
  for( i=0 ; i<loaded_size ; i++){
    (*inputs)[i] = (float*)malloc(sizeof(**inputs)*VAR_LEN);
    for( variable=0 ; variable<VAR_LEN ; variable++ ){   
      match = fscanf(file,"%f,",((*inputs)[i])+variable);
      assert(match==1);
    }
    (*outputs)[i] = (float*)malloc(sizeof(**outputs)*NB_TREES);
    for( int output_vals = 0 ; output_vals<NB_TREES ; output_vals++ ){
      match = fscanf(file,"%f,\n",(*outputs)[i]+output_vals);
      assert(match==1);
    }
  }
  fclose(file);
  return loaded_size;
}

void free_data(){

  for( int i=0 ; i<fitnessCasesSetLength ;i++ )
    free( inputs[i] );
  for( int i=0 ; i<NB_TREES ; i++ )
    free( outputs[i] );
  free( inputs );
  free( outputs );
}

/** 
    Recursive construction method for trees.
    Koza construction methods. Function set has to be ordered,
    with first every terminal nodes and then non-terminal.

    @arg constLen : length of terminal function set.
    @arg totalLen : length of the function set (non-terminal+terminal)
    @arg currentDepth : depth of the origin (sould always be 0, when the function
    is directly call)
    @arg maxDepth : The maximum depth of the resulting tree.
    @arg full : whether the construction method used has to be full (from koza's book)
                Otherwise, it will use grow method (defined in the same book).
 
    @return : pointer to the root node of the resulting sub tree
 */
GPNode* construction_method( const int constLen, const int totalLen , const int currentDepth,
			     const int maxDepth, const bool full){
  GPNode* node = new GPNode();
  
  // first select the opCode for the current Node.
  if( full ){
    if( currentDepth<maxDepth ) node->opCode = random(constLen,totalLen);
    else node->opCode = random(0, constLen);
  }
  else{
    if( currentDepth<maxDepth ) node->opCode = random(0, totalLen);
    else node->opCode = random(0, constLen);
  }
 
  int arity = opArrity[(int)node->opCode];
  node->currentArity = arity;

  // construct children (if any)
  for( int i=0 ; i<arity ; i++ )
    node->children[i] = construction_method(constLen, totalLen, currentDepth+1, maxDepth, full );
  
  // affect null to other array cells (if any)
  for( int i=arity ; i<MAX_ARITY ; i++ )
    node->children[i] = NULL;

  if( node->opCode==OP_ERC ){
    node->erc_value = random(0.,1.);
  }

  return node;
}

/**
   This function handles printing of tree.
   Every node is identify by its address, in memory,
   and labeled by the actual opCode.

   On our architecture (64bits, ubuntu 8.04 and gcc-4.3.2)
   the long int variable is sufficient to store the address
   without any warning.
 */
void toDotFile_r(GPNode* root, FILE* outputFile){
  if( root->opCode==OP_ERC )
    fprintf(outputFile," %ld [label=\"%s : %f\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str(),
	    root->erc_value);
 else
    fprintf(outputFile," %ld [label=\"%s\"];\n", (long int)root, opCodeName[(int)root->opCode].c_str());
  
  for( int i=0 ; i<root->currentArity ; i++ ){
    if( root->children[i] ){
      fprintf(outputFile,"%ld -> %ld;\n", (long int)root, (long int)root->children[i]);
      toDotFile_r( root->children[i] , outputFile);
    }
  }
}

/**
   This function prints a tree in dot (graphviz format).
   This is the entry point for the print operation. (see toDotFile_r,
   for the actual function)

   @arg root : set of trees, same type than in a individual.
   @arg baseFileName : base of filename for the output file.
   @arg treeId : the id of the tree to print, in the given set.
 */
void toDotFile(GPNode* root, const char* baseFileName, int treeId){
  std::ostringstream oss;
  oss << baseFileName << "-" << treeId << ".gv";

  FILE* outputFile = fopen(oss.str().c_str(),"w");
  if( !outputFile ){
    perror("Opening file for outputing dot representation ");
    exit(-1);
  }

  fprintf(outputFile,"digraph trees {\n");
  if(root)
    toDotFile_r( root, outputFile);
  fprintf(outputFile,"}\n");
  fclose(outputFile);
}


/**
   Compute the maximum depth of a tree, rooted on root.

   @arg root : root of the tree
   @return : depth of current tree rooted on root
 */
int depthOfTree(GPNode* root){
  int depth = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    int d = depthOfTree(root->children[i]);
    if( d>=depth ) depth = d;
  }
  return depth+1;
}


/**
   Recursively evaluate tree for given inputs
   
 */
double recEvale(GPNode* root, float* inputs){ 
  if( root->currentArity==2 ){
    double a=recEvale(root->children[0],inputs);
    double b=recEvale(root->children[1],inputs);
    switch( root->opCode ){
    case OP_MUL: return a*b;
    case OP_ADD: return a+b;
    case OP_SUB: return a-b;
    case OP_DIV:
      if( !b ) return DIV_ERR_VALUE;
      else return a/b;
    default:
      fprintf(stderr,"unknown binary opcode %d\n",root->opCode);      
      exit(-1);
    }
  }
  else if( root->currentArity==1 ){
    double a=recEvale(root->children[0],inputs);
    switch( root->opCode ){
#ifdef OP_SIN
    case OP_SIN: return sin(a);
#endif
#ifdef OP_COS
    case OP_COS: return cos(a);
#endif
#ifdef OP_EXP
    case OP_EXP: return exp(a);
#endif
    default:
      fprintf(stderr,"unknown unary opcode %d\n",root->opCode);      
      exit(-1);
    }
  }
  else 
    switch( root->opCode ){
    case OP_ERC: return root->erc_value;
    case OP_W: return inputs[0];
#ifdef OP_X
    case OP_X: return inputs[1];
#endif
#ifdef OP_Y
    case OP_Y: return inputs[2];
#ifdefOP_Z
    case OP_Z: return inputs[3];
#endif
    default:
      fprintf(stderr,"unknown terminal opcode %d\n",root->opCode);
      exit(-1);
    }
}


/**
   Fill the collection array with GPNode located at goalDepth

   @arg goalDepth: level from which GPNode are collected
   @arg collection: an empty, allocated array 
 */
int collectNodesDepth(const int goalDepth, GPNode** collection, int collected, int currentDepth, GPNode* root){

  if( currentDepth>=goalDepth ){
    collection[collected] = root;
    return collected+1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      collected=collectNodesDepth(goalDepth, collection, collected, currentDepth+1, root->children[i]);
    }
    return collected;
  }
}


/**
   Pick a node in a tree. It first pick a depth and then, it pick a 
   node amongst nodes at this depth. It returns the parent node,
   and by pointer, the childId of the choosen child.

   @arg root : the root node of the tree, amongt which we have to choose the node
   @arg chilId : pointer to an allocated int, children position of the choosen node will be stored here
   @arg depth : pointer to an allocated int, will contain the choosen depth.

   @return : return the address of the parent of the choosen node. Return null if the root node has been choosen
 */
GPNode* selectNode( GPNode* root, int* childId, int* depth){
  
  int xoverDepth = random(0,depthOfTree(root));
  (*depth) = xoverDepth;
  
  GPNode** dNodes;
  int collected;

  if(xoverDepth!=0){
    dNodes = new GPNode*[1<<(xoverDepth-1)];
    collected = collectNodesDepth(xoverDepth-1,dNodes,0,0,root);
  }
  else{
    return NULL;
  }
  int stockPointCount=0;
  for( int i=0 ; i<collected; i++ ){
    stockPointCount+=dNodes[i]->currentArity;
  }

  int reminderP = 0, parentIndexP = 0;

  int xoverP = random(0,stockPointCount);
  for( int i=0 ; ; ) 
    if( (i+dNodes[parentIndexP]->currentArity)>xoverP ){
      reminderP = xoverP-i;
      break;
    }
    else i+=dNodes[parentIndexP++]->currentArity;
  
  *childId = reminderP;
  //cout << "d of x : " << xoverDepth << "/" << depthOfTree(root)<< " n : "<< xoverP << endl;
  GPNode* ret = dNodes[parentIndexP];
  delete[] dNodes;
  return ret;
}
\end



\Before everything else function:
{
  // load data from csv file.
  cout<<"Before everything else function called "<<endl;
  fitnessCasesSetLength = load_data(&inputs,&outputs,"quadra_reg_data.csv");
  cout << "number of point in fitness cases set : " << fitnessCasesSetLength << endl;

  // Adding another stopping, as we are minimizing, the goal is 0 
  CGoalCriterion* gc = new CGoalCriterion(0,true);
  EA->stoppingCriteria.push_back(gc);
}
\end

\After everything else function:
{
  // write both trees of every individuals in a separate file.
  for( unsigned int i=0 ; i<population->actualParentPopulationSize ; i++ ){
    std::ostringstream oss;
    oss << "out/indiv-" << i << "-trees" ;
    toDotFile( ((IndividualImpl*)population->parents[i])->root[0],oss.str().c_str(),0);
  }

  // not sure that the population is not sorted now. So lets do another time (or check in the code;))
  // and dump the best individual in a graphviz file.
  population->sortParentPopulation();
  toDotFile( ((IndividualImpl*)population->parents[0])->root[0], "best-of-run",0);

  free_data();
}
\end

\At the beginning of each generation function:
  //cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\Instead evaluation function:
  cout << "yopyop" << endl;
\end

\User classes :
GPNode {
  GPNode* children[MAX_ARITY];
  char opCode;
  int currentArity;
  double erc_value;
}

GenomeClass { 
  GPNode* root[NB_TREES];
}
\end

\GenomeClass::display:
{
  os << this << " trees addr : " ;
  for( int i=0 ; i<NB_TREES ; i++ )
    os << Genome.root[i]<< "\t";
}
\end

\GenomeClass::initialiser :
{
  /**
     This is the standard ramped half-and-half method
     for creation of trees.
   */
  int id = EA->population->actualParentPopulationSize;  
  int seg = EA->population->parentPopulationSize/(TREE_DEPTH_MAX-TREE_DEPTH_MIN); 
  int currentDepth = TREE_DEPTH_MIN+id/seg;

  bool full;
  if( GROW_FULL_RATIO==0 ) full=true;
  else full = (id%seg)/(int)(seg*GROW_FULL_RATIO);

  //cout << seg << " " <<  currentDepth << " " << full ;
  for( int i=0 ; i<NB_TREES ; i++ ){
    Genome.root[i] = construction_method( constLen, totalLen , 1, currentDepth ,full);
  }
}
\end

\GenomeClass::crossover :
{

  /**
     Crossover for GP trees.
     It selects depths of cross, then selects which nodes
     will be exchanged at those depths.
   */

  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    int depthOfStock, depthOfGraft;
    GPNode** d1Nodes = NULL, ** d2Nodes = NULL;
    int reminderP1, reminderP2;
    int parentIndexP1, parentIndexP2;

    bool graftIsRoot = false;
    bool stockIsRoot = false;

    do{
      int depthP1 = depthOfTree(parent1.root[tree]);
      int depthP2 = depthOfTree(parent2.root[tree]);
    
      int xoverD1 = random(0,depthP1);
      int xoverD2 = random(0,depthP2);
      
      int maxNode1 = 1<<(depthP1-1);
      int maxNode2 = 1<<(depthP2-1);

      if( d1Nodes ) delete[] d1Nodes;
      if( d2Nodes ) delete[] d2Nodes;
    
      d1Nodes = new GPNode*[maxNode1];
      d2Nodes = new GPNode*[maxNode2];

      graftIsRoot = false;
      stockIsRoot = false;
    
      int collected1 = 0;
      int collected2 = 0;
      if( xoverD1!=0 )
	collected1 = collectNodesDepth(xoverD1-1,d1Nodes,0,0,child1.root[tree]);
      else
	stockIsRoot = true;
    
    
      if( xoverD2!=0 )
	collected2 = collectNodesDepth(xoverD2-1,d2Nodes,0,0,parent2.root[tree]);
      else
	graftIsRoot = true;
    
      int stockPointCountP1=0;
      for( int i=0 ; i<collected1 ; i++ )
	stockPointCountP1+=d1Nodes[i]->currentArity;
    
      int stockPointCountP2=0;
      for( int i=0 ; i<collected2 ; i++ )
	stockPointCountP2+=d2Nodes[i]->currentArity;
    
    
      int xoverP1 = random(0,stockPointCountP1);
      int xoverP2 = random(0,stockPointCountP2);    
    
      reminderP1    = 0; reminderP2    = 0;
      parentIndexP1 = 0; parentIndexP2 = 0;
      if( !stockIsRoot )
	for( int i=0 ; ; ) 
	  if( (i+(d1Nodes[parentIndexP1]->currentArity))>xoverP1 ){
	    reminderP1 = xoverP1-i;
	    break;
	  }
	  else i+=d1Nodes[parentIndexP1++]->currentArity;

      if( !graftIsRoot )
	for( int i=0 ; ; ) 
	  if( (i+(d2Nodes[parentIndexP2]->currentArity))>xoverP2 ){
	    reminderP2 = xoverP2-i;
	    break;
	  }
	  else i+=d2Nodes[parentIndexP2++]->currentArity;
    
      depthOfStock = xoverD1;
      if( !graftIsRoot )
	depthOfGraft = depthOfTree(d2Nodes[parentIndexP2]->children[reminderP2]);
      else 
	depthOfGraft = depthOfTree(parent2.root[tree]);
    }
    while(depthOfStock+depthOfGraft>MAX_XOVER_DEPTH);
    
    GPNode** stockPointPtr = NULL;
    GPNode* graftPointPtr = NULL;

#if 1
      toDotFile(parent1.root[0],"out/xover/p1-o",tree);
      toDotFile(parent2.root[0],"out/xover/p2-o",tree);
#endif

  
    if( !stockIsRoot ){
      delete d1Nodes[parentIndexP1]->children[reminderP1];
      d1Nodes[parentIndexP1]->children[reminderP1] = NULL;
      stockPointPtr = &d1Nodes[parentIndexP1]->children[reminderP1];
    }
    else{
      delete child1.root[tree];
      child1.root[tree] = NULL;
      stockPointPtr = &child1.root[tree];
    }

#if 1
      toDotFile(child1.root[tree],"out/xover/p1",tree);
#endif

    if( !graftIsRoot ){
      graftPointPtr = d2Nodes[parentIndexP2]->children[reminderP2];
      d2Nodes[parentIndexP2]->children[reminderP2] = NULL;
    }
    else {
      graftPointPtr = parent2.root[tree];
      parent2.root[tree] = NULL;
    }

#if 1
      toDotFile(graftPointPtr,"out/xover/graft",tree);
#endif

    (*stockPointPtr) = graftPointPtr;

#if 1
      toDotFile(child1.root[tree],"out/xover/c",tree);
#endif
    
    delete[] d1Nodes;
    delete[] d2Nodes;
  }
  child1.valid=false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{

  // Cassical  mutation
  // select a node
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    int mutationPointChildId = 0;
    int mutationPointDepth = 0;
    toDotFile( Genome.root[tree], "out/mutation/p", tree);
    GPNode* mutationPointParent = selectNode(Genome.root[tree], &mutationPointChildId, &mutationPointDepth);
    
    
    if( !mutationPointParent ){
      mutationPointParent = Genome.root[tree];
      mutationPointDepth = 0;
    }
    toDotFile( Genome.root[tree], "out/mutation/p", tree);
    delete mutationPointParent->children[mutationPointChildId] ;
    mutationPointParent->children[mutationPointChildId] = NULL;
    mutationPointParent->children[mutationPointChildId] = 
      construction_method( constLen, totalLen , 1, MAX_MUTAT_DEPTH-mutationPointDepth ,0);
    toDotFile( Genome.root[tree], "out/mutation/f", tree);
  }
  return NB_TREES;
}
\end

\GenomeClass::evaluator : // Returns the score
{
  /**
     Standard raw fitness, as in Koza's book.
     For symbolic regression, this is equal to 
     the standardized fitness.
   */
  double fitness = 0.;
  double fFit [NB_TREES];
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    fFit[tree] = 0.;
    for( int i=0 ; i<fitnessCasesSetLength ; i++ ){
      double evolvedValue = recEvale(Genome.root[tree],inputs[i]);
      fFit[tree] += fabs(evolvedValue-outputs[i][tree]);
    }
    fitness += fFit[tree];
  } 
  Genome.valid = true;
  Genome.fitness = fitness;
  return fitness;
}
\end

\User Makefile options: 
CPPFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 1       // NB_GEN
  Time limit: 0 		  // In seconds, 0 to deactivate
  Population size : 200	          //POP_SIZE
  Offspring size : 200            // 40% 
  Mutation probability : 0.1        // MUT_PROB
  Crossover probability : 0.9       // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			//Weak or Strong
  Elite: 1

  Print stats:1				//Default: 1
  Generate cvs stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
  
  
