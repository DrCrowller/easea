/*_________________________________________________________

Test functions
log normal adaptive mutation
Selection operator: Tournament
__________________________________________________________*/


\User functions:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\GenomeClass::display:
\end


\User declarations :
#include <base.h>
#include <genome.h>
#include <tree.h>
#include <omp.h>


#define X_MIN -1.
#define X_MAX 1.
#define ITER 120      
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))
#define SIGMA  1.                     /*  mutation parameter */
#define PI 3.141592654

#define G_SIZE 96 // fixme this size is defined in genome.h as GENOME_SIZE

 
float pMutPerGene=0.15;
float pMutDesCard = 0.1;

struct base* train_table = NULL;
struct base* car_table = NULL;


float* uniq_instances[2];
unsigned uniq_cnt[2];



\end

\User classes :
GenomeClass { 
  float x[G_SIZE];
}
\end


\Before everything else function:
{
  INSTEAD_EVAL_STEP = true;

  cout << "Seed : " << globalRandomGenerator->get_seed() << endl;

  //cout<<"Before everything else function called "<<endl;
  train_table = ba_postgres_load_train();
  car_table = ba_postgres_load_car();
  ba_set_links(train_table,car_table);

  ba_mix_instances(train_table);
  //ba_print_db(train_table);
  
  uniq_instances[0] = ba_compute_uniq_values(car_table, 1, uniq_cnt+0);
  uniq_instances[1] = ba_compute_uniq_values(car_table, 2, uniq_cnt+1);

  printf("%d %d\n",uniq_cnt[0],uniq_cnt[1]);

  for( unsigned i=0 ; i<uniq_cnt[0] ; i++ ){
    printf("%f,",uniq_instances[0][i]);
  }
  printf("\n");

  for( unsigned i=0 ; i<uniq_cnt[1] ; i++ ){
    printf("%f,",uniq_instances[1][i]);
  }
  printf("\n");

}
\end

\After everything else function:
{

  EA->population->sortParentPopulation();
  IndividualImpl* best = (IndividualImpl*)EA->population->parents[0];
    
  printf("best fitness %f\n",best->evaluate());
  for( unsigned i=0 ; i<G_SIZE ; i+=3 ){
    printf("%f %f >= %f\n",best->x[i],best->x[i+1],best->x[i+2]);
  }
  printf("\n");

  

  cTreeNode* root = generate_tree(best->x,train_table,car_table);
  struct base* tmp_table = table_from_genome(best->x,train_table,car_table);
  show_tree(tmp_table,root);

  struct base* tmp_learning_table, * tmp_test_table; // fixme

  tmp_learning_table = (struct base*)malloc(sizeof(*tmp_learning_table));
  tmp_test_table = (struct base*)malloc(sizeof(*tmp_test_table));
  printf("depth of resulting tree %d\n",root->tree_depth());

#if 0
  // prepare learning and test table.
  tmp_test_table->hdr = tmp_learning_table->hdr = tmp_table->hdr; // affect tmp hdr to every table.

  tmp_learning_table->no_instances =  (unsigned)(tmp_table->no_instances*(2.f/3));
  tmp_test_table->no_instances = (unsigned)(tmp_table->no_instances*(1./3));

  tmp_learning_table->instances = new float*[tmp_learning_table->no_instances];
  tmp_test_table->instances = new float*[tmp_test_table->no_instances];

  memcpy(tmp_learning_table->instances,tmp_table->instances,
	 sizeof(*tmp_learning_table->instances)*tmp_learning_table->no_instances);
  
  memcpy(tmp_test_table->instances,tmp_learning_table->no_instances+tmp_table->instances,
	 sizeof(*tmp_learning_table->instances)*tmp_test_table->no_instances);

  for( unsigned i=0 ; i<tmp_test_table->no_instances ; i++ ){
    unsigned predicted_class = root->classify_instance(tmp_test_table->instances[i]);
    unsigned real_class = (unsigned)tmp_test_table->instances[i][tmp_test_table->hdr->whichis_class];
    printf("%d - %d\n",predicted_class,real_class);
  }
#endif

  
  delete root;
  ba_delete( tmp_table );
}
\end

\GenomeClass::initialiser : 
{
  for( unsigned i=0; i<G_SIZE ; i+=3 ) {
    //Genome.x[i] = random(0,101);
    //Genome.x[i+1] = random(0,101);
    //Genome.x[i] = car_table->hdr->attributes[1]->threshold[random(0,car_table->hdr->attributes[1]->no_threshold)];
    //Genome.x[i+1] = car_table->hdr->attributes[2]->threshold[random(0,car_table->hdr->attributes[2]->no_threshold)];
    Genome.x[i] = car_table->instances[random(0,car_table->no_instances)][i+1];
    Genome.x[i+1] = car_table->instances[random(0,car_table->no_instances)][i+2];

    if( tossCoin(pMutDesCard))
      Genome.x[i+2] = 0;
    else
      Genome.x[i+2] = random(1,11);
  }
}
\end

\GenomeClass::crossover :
{
  for (int i=0; i<G_SIZE; i++){
    if( tossCoin(0.5) )
      child.x[i] = parent1.x[i];
    else
      child.x[i] = parent2.x[i];
  }
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  int NbMut=0;
  for (int i=0; i<G_SIZE; i+=GENE_SIZE){
    // mutate the cardinality
    if( tossCoin(pMutPerGene) ){
      if( tossCoin(pMutDesCard) ){
	Genome.x[i+GENE_SIZE-1] = 0;
	NbMut++;

      }
      else{
	float value = random_gauss(Genome.x[GENE_SIZE*i+GENE_SIZE-1],2);
	value = (value<0 ? 0 : value); //if value less than 0, then value is 0
	value = (value>10 ? 10 :value); // if value grether than 10 then value is 10
	
	Genome.x[i+GENE_SIZE-1] = roundf(value);
	NbMut++;

      }
    }

    for( unsigned j=0 ; j<GENE_SIZE-1 ; j++ ){
      if( tossCoin(pMutPerGene) ){
	//Genome.x[i+j] = car_table->instances[random(0,car_table->no_instances)][j+1];
	//Genome.x[i+j] = car_table->hdr->attributes[j+1]->threshold[random(0,car_table->hdr->attributes[j+1]->no_threshold)];
	
	
	float value = random_gauss(Genome.x[i+j],2);
	//value = (value<0 ? 0 : value); //if value less than 0, then value is 0
	//value = (value>101 ? 101 :value); // if value grether than 10 then value is 10
	//Genome.x[i+j] = value;

	Genome.x[i+j] = ba_nearest_greather_table_value(car_table,j+1,value);
	NbMut++;
      }
    } // for each threshold
    
  }// for each gene
  return NbMut;
}
\end

// The population evaluation.
\Instead evaluation function: 
{
  ba_mix_instances(train_table);

#pragma omp parallel for
    for( unsigned i=0 ; i<popSize ; i++ ){
      population[i]->evaluate();
    }
}
\end

\GenomeClass::evaluator : // Returns the score
{
  struct base* tmp_table = table_from_genome(Genome.x,train_table,car_table);
  struct base* tmp_learning_table, * tmp_test_table; // fixme

  float fitness_value = 0;

  tmp_learning_table = (struct base*)malloc(sizeof(*tmp_learning_table));
  tmp_test_table = (struct base*)malloc(sizeof(*tmp_test_table));

  // prepare learning and test table.
  tmp_test_table->hdr = tmp_learning_table->hdr = tmp_table->hdr; // affect tmp hdr to every table.

  tmp_learning_table->no_instances =  (unsigned)(tmp_table->no_instances*(2.f/3));
  tmp_test_table->no_instances = (unsigned)(tmp_table->no_instances*(1./3));

  tmp_learning_table->instances = new float*[tmp_learning_table->no_instances];
  tmp_test_table->instances = new float*[tmp_test_table->no_instances];
  

  memcpy(tmp_learning_table->instances,tmp_table->instances,
	 sizeof(*tmp_learning_table->instances)*tmp_learning_table->no_instances);
  
  memcpy(tmp_test_table->instances,tmp_learning_table->no_instances+tmp_table->instances,
	 sizeof(*tmp_learning_table->instances)*tmp_test_table->no_instances);
  
  cTreeNode* t = genereate_decision_tree(tmp_learning_table);
  
  for( unsigned i=0 ; i<tmp_test_table->no_instances ; i++ ){
    unsigned predicted_class = t->classify_instance(tmp_test_table->instances[i]);
    unsigned real_class = (unsigned)tmp_test_table->instances[i][tmp_test_table->hdr->whichis_class];

    // here compute classification error, or any quality measurment
    if( predicted_class!=real_class ){
      fitness_value++;
    }
  }

  fitness_value += ((float)t->tree_depth());
  delete t;

  delete[] tmp_learning_table->instances;
  delete[] tmp_test_table->instances;
  free( tmp_learning_table );
  free( tmp_test_table );
  ba_delete(tmp_table);
  
  return fitness_value;
}
\end

\User Makefile options: 
CXXFLAGS+=-I/home/maitre/sources/c4.5/include/ -fopenmp -O3 -pg
LDFLAGS+= -lpq  -O3 -lm  -fopenmp libc45.a -pg
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 100     	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 100			//POP_SIZE
  Offspring size : 100 // 40% 
  Mutation probability : 0       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 2.0
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats:1				//Default: 1
  Generate csv stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
	
