/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
__________________________________________________________*/

\User declarations :
//#include <gsl/gsl_rng.h>
#include <assert.h>
#include <errno.h>
#include <sstream>
#include <fstream>
#include <math.h>
#include <pthread.h>



#include <cutil.h>
#include <cuda_runtime_api.h>
#define TIMING 
#include <sys/time.h>
#include <timing.h>
#include <semaphore.h>

#define  OPERAND 0
int NB_FITNESS_CASES=51000;
#define DRONE_FCT_ID 7
// number of input variables
#define DRONE_VAR_LEN 19

// Here, some well known parameters for GP.
#define MAX_ARITY 2          // maximum arrity for GP nodes
#define NB_TREES 1           // number of co-evolved trees
#define TREE_DEPTH_MIN 4     // minimum size of (initial) trees (included)
#define TREE_DEPTH_MAX 9     // maximum size of (initial) trees (excluded)
#define GROW_FULL_RATIO 0.5  // ratio between grow and full construction method
#define DIV_ERR_VALUE 1.0      // Returned value, in case of non defined input value
#define MAX_XOVER_DEPTH 17
#define MAX_MUTAT_DEPTH 17

// Here, some GPGPGPU parameters
#define MAX_PROGS_SIZE 40000000

float** inputs;
float** outputs;
float* inputs_f = NULL;
float* outputs_f = NULL;
float* input_k;
float* output_k;
float* progs     = NULL;
float* progs_k   = NULL;
int* indexes     = NULL;
int* indexes_k   = NULL;
int* hits      = NULL;
int* hits_k    = NULL;
float* results   = NULL;
float* results_k = NULL;


string treeGP_to_c(const GPNode* root);
int nbGPU = 0;
#define GPUEVAL 128
#define GPUMINDIV 4
//#define CPUEVAL
//#define CPUCMP
#define MULTI_GPU
//#define INSTRUMENTED // activate instrumentation


#ifdef INSTRUMENTED
struct stats{
  struct timeval cpu_eval_res;
  struct timeval gpu_eval_res;
  struct timeval flat_trees_res;
  int popSize;
  int err;
  int gpu0Blen;
  int gpu1Blen;
  int bLen;
  float bestF;
  int bestH;
  float meanF;
  float stdDevF;
};
struct stats currentStats;
#endif

#ifdef INSTRUMENTED
FILE* gpu_stat_file = NULL;
#endif
int fitnessCasesSetLength;

/** For the sake of simplicity, constant operators become first in the function set
    Koza defines 2 operator sets, one for constants, another for function.

    @TODO
    Terminal variables could be encoded differently, for example using one opCode for every
    variable, and another field to encode the id of the variable (what about the likelyhood of having 
    each variable (this sould divide by the number of variables)
*/
//#define OP 1
#if 1
enum OPCODE               { OP_ERC, OP_VAR, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OP_POW, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "x" , "*"   , "+"   , "-"   , "/"     , "^"   };
int opArrity[] =          { 0     , 0     , 2     , 2     , 2     , 2     , 2     };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#define OP_X -1
#define OP_Y -2
#define OP_Z -3
#define OP_SIN -4
#define OP_COS -5
#endif

//#define OP 1
#if 0
enum OPCODE               { OP_ERC, OP_VAR, OP_MUL, OP_ADD, OP_SUB, OP_DIV, OPCODE_SIZE, OP_RETURN};
const string opCodeName[]={ "erc" , "x" , "*"   , "+"   , "-"   , "/"     };
int opArrity[] =          { 0     , 0     , 2     , 2     , 2     , 2     };
int constLen = 2;
int totalLen = OPCODE_SIZE;
#define OP_X -1
#define OP_Y -2
#define OP_Z -3
#define OP_SIN -4
#define OP_COS -5
#define OP_POW -6
#endif

#define OUTPUT_DATA_ID 0
#include "tgp_regressionEval.cu"
\end

\User functions:
#define PI (3.141592653589793)
#define MILLION_I 1000000

struct timeval global_eval_beg, global_eval_end, global_eval_res;
struct timeval global_eval_acc;    


/* Convert a timeval to microseconds as a long */
long misc_tv_usec_l(struct timeval *t){
  return ((long) t->tv_sec * MILLION_I) + t->tv_usec;
}

#ifdef INSTRUMENTED
void publish_mgpu_32(){
  fprintf(gpu_stat_file,",,%ld,",EA->getCurrentGeneration());

  fprintf(gpu_stat_file,"%d,%d,%f,%d,",currentStats.gpu0Blen,currentStats.gpu1Blen,(double)currentStats.gpu0Blen/currentStats.gpu1Blen,currentStats.bLen);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.flat_trees_res.tv_sec,currentStats.flat_trees_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.cpu_eval_res.tv_sec,currentStats.cpu_eval_res.tv_usec);
  fprintf(gpu_stat_file,"%ld.%06ld,",currentStats.gpu_eval_res.tv_sec,currentStats.gpu_eval_res.tv_usec);

  double speedUp = misc_tv_usec_l(&currentStats.cpu_eval_res)/misc_tv_usec_l(&currentStats.gpu_eval_res);
  fprintf(gpu_stat_file,"%0.0f,%0f,",speedUp,(double)(currentStats.popSize-currentStats.err)/(double)currentStats.popSize);
  fprintf(gpu_stat_file,"%f,%d,",currentStats.bestF,currentStats.bestH);
  fprintf(gpu_stat_file,"%f,%f,",currentStats.meanF,currentStats.stdDevF);
  fprintf(gpu_stat_file,"\n");
  fflush(gpu_stat_file);
}
#endif


/**
   This function allows to load data from the Stephane output file format (mostly csv file),
   with multiple input variables and one result.

   It loads DRONE_VAR_LEN input variables and the the OUTPUT_DATA_ID th output result.
   
   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)
   @name name of the input file.

   @ret number of loaded fitness cases (should be equal to NB_FITNESS_CASES).
 */
int load_drone_data(float*** data, const string& name){
  FILE* file = fopen(name.c_str(),"r");
  if( !file ){
    perror("Opening drone data file");
    exit(-1);
  }
  int match;
  int loaded_size = NB_FITNESS_CASES;

  (*data) = (float**)malloc(sizeof(*data)*loaded_size);
  for( int i=0 ; i<loaded_size; i++){
    (*data)[i] = (float*)malloc(sizeof(**data)*DRONE_VAR_LEN);
    for( int variable=0 ; variable<DRONE_VAR_LEN ; variable++ ){
      match = fscanf(file,"%f,",((*data)[i])+variable);
      assert(match==1);
    }
  }
  return loaded_size;
}


void free_data_drone(){
  for( int i=0 ; i<fitnessCasesSetLength ;i++ )
    free( inputs[i] );
  free( inputs );
}

/**
   Recursive construction method for trees.
   Koza construction methods. Function set has to be ordered,
   with first every terminal nodes and then non-terminal.

   @arg constLen : length of terminal function set.
   @arg totalLen : length of the function set (non-terminal+terminal)
   @arg currentDepth : depth of the origin (sould always be 0, when the function
   is directly call)
   @arg maxDepth : The maximum depth of the resulting tree.
   @arg full : whether the construction method used has to be full (from koza's book)
   Otherwise, it will use grow method (defined in the same book).
 
   @return : pointer to the root node of the resulting sub tree
*/
GPNode* construction_method( const int constLen, const int totalLen , const int currentDepth,
			     const int maxDepth, const bool full, GPNode* parentPtr){
  GPNode* node = new GPNode();
  // first select the opCode for the current Node.
  if( full ){
    if( currentDepth<maxDepth ) node->opCode = random(constLen,totalLen);
    else node->opCode = random(0, constLen);
  }
  else{
    if( currentDepth<maxDepth ) node->opCode = random(0, totalLen);
    else node->opCode = random(0, constLen);
  }
 
  int arity = opArrity[(int)node->opCode];
  node->currentArity = arity;

  // construct children (if any)
  for( int i=0 ; i<arity ; i++ )
    node->children[i] = construction_method(constLen, totalLen, currentDepth+1, maxDepth, full, node);
  
  // affect null to other array cells (if any)
  for( int i=arity ; i<MAX_ARITY ; i++ )
    node->children[i] = NULL;

  if( node->opCode==OP_ERC ){
    node->erc_value = random(0.,1.);
  }
  else if( node->opCode==OP_VAR )
    node->var_id = random(1,DRONE_VAR_LEN);

  return node;
}

/**
   This function handles printing of tree.
   Every node is identify by its address, in memory,
   and labeled by the actual opCode.

   On our architecture (64bits, ubuntu 8.04/9.04 and gcc-4.3.2)
   the long int variable is sufficient to store the address
   without any warning.
*/
void toDotFile_r(GPNode* root, FILE* outputFile){
  if( root->opCode==OP_ERC )
    fprintf(outputFile," %ld [label=\"%d->%s : %f\"];\n", (long int)root, root->opCode, opCodeName[(int)root->opCode].c_str(),
	    root->erc_value);
  else if( root->opCode==OP_VAR )
    fprintf(outputFile," %ld [label=\"%d->%s : %d\"];\n", (long int)root, root->opCode, opCodeName[(int)root->opCode].c_str(), root->var_id);
  else
    fprintf(outputFile," %ld [label=\"%d->%s\"];\n", (long int)root, root->opCode, opCodeName[(int)root->opCode].c_str());
  
  for( int i=0 ; i<root->currentArity ; i++ ){
    if( root->children[i] ){
      fprintf(outputFile,"%ld -> %ld;\n", (long int)root, (long int)root->children[i]);
      toDotFile_r( root->children[i] , outputFile);
    }
  }
}

/**
   This function prints a tree in dot (graphviz format).
   This is the entry point for the print operation. (see toDotFile_r,
   for the actual function)

   @arg root : set of trees, same type than in a individual.
   @arg baseFileName : base of filename for the output file.
   @arg treeId : the id of the tree to print, in the given set.
*/
void toDotFile(GPNode* root, const char* baseFileName, int treeId){
  std::ostringstream oss;
  oss << baseFileName << "-" << treeId << ".gv";

  FILE* outputFile = fopen(oss.str().c_str(),"w");
  if( !outputFile ){
    perror("Opening file for outputing dot representation ");
    exit(-1);
  }

  fprintf(outputFile,"digraph trees {\n");
  if(root)
    toDotFile_r( root, outputFile);
  fprintf(outputFile,"}\n");
  fclose(outputFile);
}


/**
   Compute the maximum depth of a tree, rooted on root.

   @arg root : root of the tree
   @return : depth of current tree rooted on root
*/
int depthOfTree(GPNode* root){
  int depth = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    int d = depthOfTree(root->children[i]);
    if( d>=depth ) depth = d;
  }
  return depth+1;
}


/**
   Recursively evaluate tree for given inputs   
*/
float recEvaleDrone(GPNode* root, float* data) {
  if( root->currentArity==2 ){
    float op1=recEvaleDrone(root->children[0],data);
    float op2=recEvaleDrone(root->children[1],data);
    switch( root->opCode ){
    case OP_MUL: return op1*op2;
    case OP_ADD: return op1+op2;
    case OP_SUB: return op1-op2;
    case OP_POW: return powf(op1,op2);
    case OP_DIV:
      if( !op2 ) return DIV_ERR_VALUE;
      else return op1/op2;
    default:
      fprintf(stderr,"unknown binary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else if( root->currentArity==1 ){
    float op1=recEvaleDrone(root->children[0],data);
    switch( root->opCode ){
    case OP_SIN: return sinf(op1);
    case OP_COS: return cosf(op1);
      /*     case OP_EXP: return exp(a); */
    default:
      fprintf(stderr,"unknown unary opcode %d\n",root->opCode);
      exit(-1);
    }
  }
  else
    switch( root->opCode ){
    case OP_ERC: return root->erc_value;
    case OP_VAR: return data[root->var_id];
    default:
      fprintf(stderr,"unknown terminal opcode %d\n",root->opCode);
      exit(-1);
    }
}


/**
   Fill the collection array with GPNode located at goalDepth

   @arg goalDepth: level from which GPNode are collected
   @arg collection: an empty, allocated array
*/
int collectNodesDepth(const int goalDepth, GPNode** collection, int collected, int currentDepth, GPNode* root){

  if( currentDepth>=goalDepth ){
    collection[collected] = root;
    return collected+1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      collected=collectNodesDepth(goalDepth, collection, collected, currentDepth+1, root->children[i]);
    }
    return collected;
  }
}


/**
   Pick a node in a tree. It first pick a depth and then, it pick a
   node amongst nodes at this depth. It returns the parent node,
   and by pointer, the childId of the choosen child.

   @arg root : the root node of the tree, amongt which we have to choose the node
   @arg chilId : pointer to an allocated int, children position of the choosen node will be stored here
   @arg depth : pointer to an allocated int, will contain the choosen depth.

   @return : return the address of the parent of the choosen node. Return null if the root node has been choosen
*/
GPNode* selectNode( GPNode* root, int* childId, int* depth){
  
  int xoverDepth = random(0,depthOfTree(root));
  (*depth) = xoverDepth;
  
  GPNode** dNodes;
  int collected;

  if(xoverDepth!=0){
    dNodes = new GPNode*[1<<(xoverDepth-1)];
    collected = collectNodesDepth(xoverDepth-1,dNodes,0,0,root);
  }
  else{
    return NULL;
  }
  int stockPointCount=0;
  for( int i=0 ; i<collected; i++ ){
    stockPointCount+=dNodes[i]->currentArity;
  }

  int reminderP = 0, parentIndexP = 0;

  int xoverP = random(0,stockPointCount);
  for( int i=0 ; ; )
    if( (i+dNodes[parentIndexP]->currentArity)>xoverP ){
      reminderP = xoverP-i;
      break;
    }
    else i+=dNodes[parentIndexP++]->currentArity;
  
  *childId = reminderP;
  //cout << "d of x : " << xoverDepth << "/" << depthOfTree(root)<< " n : "<< xoverP << endl;
  GPNode* ret = dNodes[parentIndexP];
  delete[] dNodes;
  return ret;
}
			 
void flattenDatas( float** inputs, int length, int width, float** flat_inputs){
  (*flat_inputs)=(float*)malloc(sizeof(float)*length*width);
  for( int i=0 ; i<length ; i++ ){
    for( int j=0 ; j<width ; j++ ){
      (*flat_inputs)[i*width+j] = inputs[i][j];
    }
  }
}

/**
   Send input and output data on the GPU memory.
   Allocate
*/
void initialDataToGPU(float* input_f, int length_input, float* output_f, int length_output){
  printf("is : %d, os : %d\n",length_input, length_output);
  // allocate and copy input/output arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)(&input_k),sizeof(float)*length_input));
  CUDA_SAFE_CALL(cudaMalloc((void**)(&output_k),sizeof(float)*length_output));
  CUDA_SAFE_CALL(cudaMemcpy(input_k,input_f,sizeof(float)*length_input,cudaMemcpyHostToDevice));
  CUDA_SAFE_CALL(cudaMemcpy(output_k,output_f,sizeof(float)*length_output,cudaMemcpyHostToDevice));

  // allocate indexes and programs arrays
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);
  CUDA_SAFE_CALL(cudaMalloc((void**)&indexes_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL( cudaMalloc((void**)&progs_k,sizeof(*progs_k)*MAX_PROGS_SIZE));

  // allocate hits and results arrays
  CUDA_SAFE_CALL(cudaMalloc((void**)&results_k,sizeof(*indexes_k)*maxPopSize));
  CUDA_SAFE_CALL(cudaMalloc((void**)&hits_k,sizeof(*indexes_k)*maxPopSize));
}

/**
   Free gpu memory from the input and ouput arrays.
*/
void free_gpu(){
  cudaFree(input_k);
  cudaFree(output_k);
  cudaFree(progs_k);
  cudaFree(indexes_k);
  cout << "GPU freed" << endl;
}

/**
   Convert tree individual in flat, rpn representation.
   Most of operator are just represented by their number, other namely, ERC and VAR
   use 2 float, one for the OPCODE another for the value of the erc or the id of the variable

   @ARG root : the root node of the individual to convert.
   @ARG buf : the destination buffer, where the population will be flattened.
   @ARG index : a pointer to a counter which point to the first available cell in the array.

   @RET : return 1 if the node have been correctly flattened, 0 if the size of the buffer (MAX_PROGS_SIZE)
   had been exceeded. 

   @TODO : the error control sould not work yet. It could be a problem, but it is indeed faster in this situation.
 */
int flattening_tree_rpn( GPNode* root, float* buf, int* index){
  int i;
  assert( (*index)+1 < MAX_PROGS_SIZE );
  for( i=0 ; i<root->currentArity ; i++ ){
    flattening_tree_rpn(root->children[i],buf,index);
  }

  buf[(*index)++] = root->opCode;
  if( root->opCode == OP_ERC ) buf[(*index)++] = root->erc_value;
  if( root->opCode == OP_VAR ) buf[(*index)++] = root->var_id;
  return 1;
}

int enumTreeNodes(GPNode* root){
  int nbNode = 0;
  for( int i=0 ; i<root->currentArity ; i++ ){
    nbNode+=enumTreeNodes(root->children[i]);
  }
  return nbNode+1;
}


GPNode* pickNthNode(GPNode* root, int N, int* childId){
  
  GPNode* stack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  GPNode* parentStack[MAX(MAX(MAX_XOVER_DEPTH,MAX_MUTAT_DEPTH),TREE_DEPTH_MAX)*MAX_ARITY];
  int stackPointer = 0;

  parentStack[stackPointer] = NULL;
  stack[stackPointer++] = root;

  for( int i=0 ; i<N ; i++ ){
    GPNode* currentNode = stack[stackPointer-1];
    //cout <<  currentNode << endl;
    stackPointer--;
    for( int j=currentNode->currentArity ; j>0 ; j--){
      parentStack[stackPointer] = currentNode;
      stack[stackPointer++] = currentNode->children[j-1];
    }
  }

  //assert(stackPointer>0);
  if( stackPointer )
    stackPointer--;
  
  //cout << "f : \n\t n :" << stack[stackPointer ] << "\n\t p :" << parentStack[stackPointer] << " cId : " << (*childId) << endl;
  
  for( int i=0 ; i<parentStack[stackPointer]->currentArity ; i++ ){
    if( parentStack[stackPointer]->children[i]==stack[stackPointer] ){
      (*childId)=i;
      break;
    }
  }
  

  return parentStack[stackPointer];
}


int depthOfNode(GPNode* root, GPNode* node){

  if( root==node ){
    return 1;
  }
  else{
    for( int i=0 ; i<root->currentArity ; i++ ){
      int depth = depthOfNode(root->children[i],node);
      if( depth )
	return depth+1;
    }
    return 0;
  }
}

void simpleCrossOver(IndividualImpl& p1, IndividualImpl& p2, IndividualImpl& c){
  int depthP1 = depthOfTree(p1.root[0]);
  int depthP2 = depthOfTree(p2.root[0]);

  int nbNodeP1 = enumTreeNodes(p1.root[0]);
   int nbNodeP2 = enumTreeNodes(p2.root[0]);

  int stockPointChildId=0;
  int graftPointChildId=0;

  bool stockCouldBeTerminal = tossCoin(0.1);
  bool graftCouldBeTerminal = tossCoin(0.1);

  int childrenDepth = 0, Np1 = 0 , Np2 = 0;
  GPNode* stockParentNode = NULL;
  GPNode* graftParentNode = NULL;

  do{
  choose_node:
    /* Np1 = (int)random((int)0,(int)nbNodeP1); */
    /* Np2 = (int)random((int)0,(int)nbNodeP2); */

    if( nbNodeP1<2 ) Np1=0;
    else Np1 = (int)random((int)0,(int)nbNodeP1);
    if( nbNodeP2<2 ) Np2=0;
    else Np2 = (int)random((int)0,(int)nbNodeP2);

    
    if( Np1!=0 ) stockParentNode = pickNthNode(c.root[0], MIN(Np1,nbNodeP1) ,&stockPointChildId);
    if( Np2!=0 ) graftParentNode = pickNthNode(p2.root[0], MIN(Np2,nbNodeP1) ,&graftPointChildId);

    // is the stock and the graft an authorized type of node (leaf or inner-node)
    if( Np1 && !stockCouldBeTerminal && stockParentNode->children[stockPointChildId]->currentArity==0 ) goto choose_node;
    if( Np2 && !graftCouldBeTerminal && graftParentNode->children[graftPointChildId]->currentArity==0 ) goto choose_node;
    
    if( Np2 && Np1)
      childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthOfTree(graftParentNode->children[graftPointChildId]);
    else if( Np1 ) childrenDepth = depthOfNode(c.root[0],stockParentNode)+depthP1;
    else if( Np2 ) childrenDepth = depthOfTree(graftParentNode->children[graftPointChildId]);
    else childrenDepth = depthP2;
    
  }while( childrenDepth>MAX_XOVER_DEPTH );
  
  if( Np1 && Np2 ){
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }
  else if( Np1 ){ // && Np2==NULL
    // We want to use the root of the parent 2 as graft
    delete stockParentNode->children[stockPointChildId];
    stockParentNode->children[stockPointChildId] = p2.root[0];
    p2.root[0] = NULL;
  }else if( Np2 ){ // && Np1==NULL
    // We want to use the root of the parent 1 as stock
    delete c.root[0];
    c.root[0] = graftParentNode->children[graftPointChildId];
    graftParentNode->children[graftPointChildId] = NULL;
  }else{
    // We want to switch root nodes between parents
    delete c.root[0];
    c.root[0]  = p2.root[0];
    p2.root[0] = NULL;
  }
}


void treeGP_to_cr(const GPNode* root, ostringstream& oss){

  if( root->currentArity == 2 ){
    oss << "(" ;
    treeGP_to_cr(root->children[0],oss);
    oss <<  opCodeName[root->opCode] ;
    treeGP_to_cr(root->children[1],oss);
    oss << ")";
  }
  else if( root->currentArity==1 ){
    oss << opCodeName[root->opCode] << "(";
    treeGP_to_cr(root->children[0],oss);
    oss << ")";
  }
  else if( root->currentArity==0 ){
    if( root->opCode==OP_ERC )
      oss << root->erc_value;
    else if( root->opCode == OP_VAR )
      oss << opCodeName[root->opCode] << "[" <<root->var_id << "]";
    else oss << opCodeName[root->opCode] ;


  }
  else{
    cerr << "unexpected arity " << endl;
    exit(-1);
  }
}


string treeGP_to_c(const GPNode* root){
  ostringstream oss;
  treeGP_to_cr(root,oss);  
  return oss.str();
}


class HitGoal : public CStoppingCriterion{  
  bool reached(){
    return false;
  }
};


\end
// end of user definition body

 
\Before everything else function:
{
  global_eval_acc.tv_sec = 0.;                                 
  global_eval_acc.tv_usec = 0.;
  
#ifdef CPUEVAL
  printf("eval on CPU\n");
#endif
#ifdef GPUEVAL
  printf("eval on GPU\n");
#endif
  
  NB_FITNESS_CASES = setVariable("u3",NB_FITNESS_CASES);
  cout << "nb of ordered fc : " << NB_FITNESS_CASES << endl;
 
  int maxPopSize = MAX(EA->population->parentPopulationSize,EA->population->offspringPopulationSize);
  fitnessCasesSetLength = load_drone_data(&inputs,"data/data_sample1-100.csv");
  cout << "number of point in fitness cases set : " << fitnessCasesSetLength << endl;

  inputs_f = NULL;
  outputs_f = NULL;

  flattenDatas(inputs,fitnessCasesSetLength,DRONE_VAR_LEN,&inputs_f);

  indexes = new int[maxPopSize];
  hits    = new int[maxPopSize];
  results = new float[maxPopSize];
  progs   = new float[MAX_PROGS_SIZE];
  
  INSTEAD_EVAL_STEP=true;
  
  // Adding another stopping, as we are minimizing, the goal is 0
  /* CGoalCriterion* gc = new CGoalCriterion(0,true); */
  /* EA->stoppingCriteria.push_back(gc); */

  HitGoal* hg = new HitGoal();
  EA->stoppingCriteria.push_back(hg);

#ifdef GPUEVAL
#ifdef MULTI_GPU
  // This section implements the multi-gpu approach
  int count;
  cudaGetDeviceCount(&count);
  printf("Number of devices : %d\n", count);

  pthread_t* t = (pthread_t*)malloc(sizeof(pthread_t)*count);
  gpuArgs = (struct gpuArg*)malloc(sizeof(struct gpuArg)*count);

  nbGPU = count;
  // here we want to create one thread per GPU
  for( int i=0 ; i<count ; i++ ){
    gpuArgs[i].threadId = i;

    sem_init(&gpuArgs[i].sem_in,0,0);
    sem_init(&gpuArgs[i].sem_out,0,0);

    if( pthread_create(t+i,NULL,gpuThreadMain,gpuArgs+i) ) 
      perror("pthread_create : "); 
  }
#else
  nbGPU=1;
  // Here starts the CUDA parts
  cudaSetDevice(1); // on GTX295 ;) we want to use the second card for computation
  initialDataToGPU(inputs_f, fitnessCasesSetLength*DRONE_VAR_LEN, NULL, 0);
#endif
#endif
  cout << "seed is : " << EA->params->seed << endl;
  cout <<  "function in the fs are : " << endl;
  for( int i=0 ; i<OPCODE_SIZE ; i++ )
    fprintf(stdout,"%s,",opCodeName[i].c_str());
  fprintf(stdout,"\n");
  cout << "problem is " << "Drone regression function : " << DRONE_FCT_ID << endl;

#ifdef INSTRUMENTED
  ostringstream output_file_name;
  output_file_name << "stats/gpu_stat_file" << "-ps" << EA->params->parentPopulationSize << "-os" << EA->params->offspringPopulationSize 
		   << "-fc" << NB_FITNESS_CASES << "-s"<< EA->params->seed <<".csv";
  // gpu statistics file
  gpu_stat_file = fopen(output_file_name.str().c_str(),"a");
  //  gpu_stat_file = stdout;
  if( !gpu_stat_file ){
    perror("opening the gpu statistics file");
    exit(-1);
  }
  fprintf(gpu_stat_file,"seed,%ld\n",EA->params->seed);
  fprintf(gpu_stat_file,"blockDim,%d\n",GPUEVAL);
  fprintf(gpu_stat_file,"indivPerBlock,%d\n",(GPUEVAL==32?GPUMINDIV:1));
  fprintf(gpu_stat_file,"nbGPU,%d\n",nbGPU);
  fprintf(gpu_stat_file,"FitCaseLen,%d\n",fitnessCasesSetLength);

  for( int i=0 ; i<OPCODE_SIZE ; i++ )
    fprintf(gpu_stat_file,"%s,",opCodeName[i].c_str());
  fprintf(gpu_stat_file,"\n");
  fprintf(gpu_stat_file,"problem name,%s\n","Drone regression function");
  fprintf(gpu_stat_file,",,gen,");

#ifdef MULTI_GPU
  for( int i=0 ; i<nbGPU ; i++ )
    fprintf(gpu_stat_file,"G%d Blezn,",i);
  fprintf(gpu_stat_file,"buf ratio,");
#endif
#ifdef GPUEVAL
  fprintf(gpu_stat_file,"total pLen,");
  fprintf(gpu_stat_file,"ftime,gpuETime,");
#endif
#ifdef CPUEVAL
  fprintf(gpu_stat_file,"cpuETime,SU,");
#endif
#ifdef CPUCMP
  fprintf(gpu_stat_file,"correct ratio,");
#endif
  fprintf(gpu_stat_file,"bestF,bestH,avgF,stdDevF\n");
#endif
}
\end

\After everything else function:
{
  // write tree of every individuals in a separate file.
  /* for( unsigned int i=0 ; i<population->actualParentPopulationSize ; i++ ){ */
  /*   std::ostringstream oss; */
  /*   oss << "out/indiv-" << i << "-trees" ; */
  /*   toDotFile( ((IndividualImpl*)population->parents[i])->root[0],oss.str().c_str(),0); */
  /* } */

  // not sure that the population is sorted now. So lets do another time (or check in the code;))
  // and dump the best individual in a graphviz file.
  population->sortParentPopulation();
  toDotFile( ((IndividualImpl*)population->parents[0])->root[0], "best-of-run",0);
  // here we will dump a c-like expression of the same individual
  ofstream fichier("best-of-run.exp", ios::out | ios::trunc);
  fichier << treeGP_to_c( ((IndividualImpl*)population->parents[0])->root[0] ) << endl;
  fichier.close();
  
  // delete some global arrays
  delete[] indexes; delete[] hits;
  delete[] results; delete[] progs;

#ifdef GPUEVAL  
#ifdef MULTI_GPU
  freeGPU=true;
  wake_up_gpu_thread(nbGPU);
#else
  free_gpu();
#endif
#endif
  free_data_drone();

#ifdef INSTRUMENTED
  fclose(gpu_stat_file);
#endif
  SHOW_TIME_ACC(global_eval);
}
\end

\At the beginning of each generation function:
  //cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
{
  //cout << "At the end of each generation function called" << endl;
#ifdef INSTRUMENTED
  currentStats.bestF = EA->population->Best->fitness;
  currentStats.bestH = ((IndividualImpl*)EA->population->Best)->hits;
  currentStats.meanF = EA->currentAverageFitness;
  currentStats.stdDevF = EA->currentSTDEV;
  publish_mgpu_32();
#endif
  fflush(stdout);
}
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\Instead evaluation function:
{
  TIME_ST(global_eval);
#ifdef GPUEVAL
#ifdef INSTRUMENTED
  DECLARE_TIME(gpu_eval);
  TIME_ST(gpu_eval);

  DECLARE_TIME(flat_trees);
  TIME_ST(flat_trees);
#endif
  int index = 0;
  for( int i=0 ; i<popSize ; i++ ){
    indexes[i] = index;
    flattening_tree_rpn( ((IndividualImpl*)population[i])->root[0], progs, &index);
    progs[index++] = OP_RETURN;
  }

#ifdef INSTRUMENTED
  TIME_END(flat_trees); 
  currentStats.bLen = index;
#endif

#ifdef MULTI_GPU
  notify_gpus(progs, indexes, index, population,popSize, nbGPU);
#ifdef INSTRUMENTED
  TIME_END(gpu_eval);
#endif
#else
  CUDA_SAFE_CALL(cudaMemcpy( progs_k, progs, sizeof(float)*index, cudaMemcpyHostToDevice ));
  CUDA_SAFE_CALL(cudaMemcpy( indexes_k, indexes, sizeof(float)*popSize, cudaMemcpyHostToDevice ));

  // Here we will do the real GPU evaluation
#if 1
  EvaluatePostFixIndividuals_128_mgpu<<<popSize,128>>>( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength, results_k, hits_k, indexes_k,0,0);
#else
  int indivPerBlock = 4;
  dim3 numthreads;
  numthreads.x = 32;
  numthreads.y = indivPerBlock;
  fastEvaluatePostFixIndividuals_32_mgpu
    <<<popSize/indivPerBlock,numthreads,NUMTHREAD*sizeof(float)*2*indivPerBlock>>>
    ( progs_k, index, popSize, input_k, output_k, fitnessCasesSetLength,results_k, hits_k, indivPerBlock, indexes_k,0,0);
#endif
  cudaThreadSynchronize();

  CUDA_SAFE_CALL(cudaMemcpy( hits, hits_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));
  CUDA_SAFE_CALL(cudaMemcpy( results, results_k, sizeof(float)*popSize, cudaMemcpyDeviceToHost));

#ifdef INSTRUMENTED
  TIME_END(gpu_eval);
#endif
#endif
#endif //ifdef GPUEVAL

#ifdef INSTRUMENTED
  int err=0;
  DECLARE_TIME(cpu_eval);
  TIME_ST(cpu_eval);
#endif

#ifdef CPUEVAL
  for( int i=0 ; i<popSize ; i++ ){
    population[i]->evaluate();
    population[i]->valid = true;
    //printf("%d : %f | %f\n",i,population[i]->getFitness(),results[i]);
#ifdef CPUCMP
    if( fabs(results[i]-population[i]->getFitness())>population[i]->getFitness()*0.01){
      err++;
    }
#endif
  }
#endif


#ifdef INSTRUMENTED
  TIME_END(cpu_eval);
  COMPUTE_TIME(flat_trees);
  COMPUTE_TIME(cpu_eval);
  COMPUTE_TIME(gpu_eval);
#endif

#ifdef GPUEVAL
  for( int i=0 ; i<popSize ; i++ ){
    population[i]->fitness = results[i];
    ((IndividualImpl*)population[i])->hits = hits[i];
    population[i]->valid = true;
  }
#endif

#ifdef INSTRUMENTED
  currentStats.cpu_eval_res = cpu_eval_res;
  currentStats.gpu_eval_res = gpu_eval_res;
  currentStats.flat_trees_res = flat_trees_res;
  currentStats.popSize = popSize;
  currentStats.err = err;
#endif
  TIME_END(global_eval);
  TIME_ACC(global_eval);
}
\end

\User classes :
GPNode {
  GPNode* children[MAX_ARITY];
  char opCode;
  int currentArity;
  double erc_value;
  int var_id ;
}

GenomeClass {
  GPNode* root[NB_TREES];
  int hits;
}
\end

\GenomeClass::display:
{
  os << this << " trees addr : " ;
  for( int i=0 ; i<NB_TREES ; i++ )
    os << Genome.root[i]<< "\t";
}
\end

\GenomeClass::initialiser :
{
  /**
     This is the standard ramped half-and-half method
     for creation of trees.
   */
  int id = EA->population->actualParentPopulationSize;  
  int seg = EA->population->parentPopulationSize/(TREE_DEPTH_MAX-TREE_DEPTH_MIN); 
  int currentDepth = TREE_DEPTH_MIN+id/seg;

  bool full;
  if( GROW_FULL_RATIO==0 ) full=true;
  else full = (id%seg)/(int)(seg*GROW_FULL_RATIO);

  //cout << seg << " " <<  currentDepth << " " << full ;
  for( int i=0 ; i<NB_TREES ; i++ ){
    Genome.root[i] = construction_method( constLen, totalLen , 1, currentDepth ,full, Genome.root[i] );
  }
  hits = 0;
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{

  printf("mutation called !!!!\n");
  // Cassical  mutation
  // select a node
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    int mutationPointChildId = 0;
    int mutationPointDepth = 0;
    GPNode* mutationPointParent = selectNode(Genome.root[tree], &mutationPointChildId, &mutationPointDepth);
    
    if( !mutationPointParent ){
      mutationPointParent = Genome.root[tree];
      mutationPointDepth = 0;
    }
    delete mutationPointParent->children[mutationPointChildId] ;
    mutationPointParent->children[mutationPointChildId] = NULL;
    mutationPointParent->children[mutationPointChildId] = 
      construction_method( constLen, totalLen , 1, MAX_MUTAT_DEPTH-mutationPointDepth ,0, mutationPointParent->children[mutationPointChildId]);
  }
  return NB_TREES;
}
\end

\GenomeClass::evaluator : // Returns the score
{
  /**
     Standard raw fitness, as in Koza's book.
     For symbolic regression, this is equal to 
     the standardized fitness.
   */
  double fitness = 0.;
  double fFit [NB_TREES];
  hits=0;
  for( int tree=0 ; tree<NB_TREES ; tree++ ){
    fFit[tree] = 0.;
    for( int i=0 ; i<fitnessCasesSetLength-1 ; i++ ){
      float evolvedValue = recEvaleDrone(Genome.root[tree],inputs[i]);
      float result = fabs(evolvedValue-inputs[i+1][DRONE_FCT_ID]);
      fFit[tree] += result;
      if (result <= HIT_LEVEL)
	hits++;
    }
    fitness += fFit[tree];
  } 
  Genome.valid = true;
  Genome.fitness = fitness;

  return fitness;
}
\end

\User Makefile options: 

CXXFLAGS+=-I/usr/local/cuda/common/inc/ -I/usr/local/cuda/include/
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 1       // NB_GEN
  Time limit: 0 		  // In seconds, 0 to deactivate
  Population size : 4096          //POP_SIZE
  Offspring size : 4096           // 40% 
  Mutation probability : 0       // MUT_PROB
  Crossover probability : 0.9     // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1

  Print stats:1				//Default: 1
  Generate cvs stats file:0			
  Generate gnuplot script:0
  Generate R script:0
  Plot stats:0				//Default: 0
\end
