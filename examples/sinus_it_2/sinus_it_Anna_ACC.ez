/*_________________________________________________________

Pierre Collet 01/05/20
Note that EASEA filenames cannot contain dashes "-" but they
can contain underscores "_" as is the case with sinus_it.ez
__________________________________________________________*/

\User declarations :

#define NB_SIN  2               // but you can try a different value

double iACC_MULT=1024*1024;
#define PI  3.14159265358979323846
#define MIN_AMP 30.0 // At least one tenths the minimum sine amplitude
#define MAX_AMP 100000.0 // At least ten times the maximum sine amplitude
#define MIN_FREQ 0.26*iACC_MULT   //  677*nACC_MULT
#define MAX_FREQ 0.27*iACC_MULT  //681*nACC_MULT
#define MIN_PH 0.0
#define MAX_PH 2*PI

#define NB_SAMPLES 64 //4096 //8192 //16384 //8192 //131072 //8192 //4096       // number of samples to be created

float fX_MIN;
float fX_MAX;

TV fSAMPLE[NB_SAMPLES][2]; //  2nd dimension is x value [0] and y value [1]
TV fTARGET_SIN[NB_SIN][3]; // [0] = amplitude, [1] = frequence, [2] = phase

#define NB_VARIABLES NB_SIN*3
#define NB_OBJECTIVES 1
TBoundary setBoundaryLocal(const size_t dimension)
{
        TBoundary boundary(dimension);
        for (size_t i = 0; i < NB_SIN; ++i)
        {
                boundary[i*3+0].first = MIN_AMP;//coco_problem_get_smallest_values_of_interest(PROBLEM)[i];
        
                boundary[i*3+0].second = MAX_AMP;//coco_problem_get_largest_values_of_interest(PROBLEM)[i];
        
boundary[i*3+1].first = MIN_FREQ;
boundary[i*3+1].second = MAX_FREQ;
boundary[i*3+2].first = MIN_PH;
boundary[i*3+2].second = MAX_PH;

        }

        return boundary;
}
TP m_problem(NB_OBJECTIVES, NB_VARIABLES, setBoundaryLocal(NB_VARIABLES));


__device__  TV gpuSample[NB_SAMPLES][2];

\end

\User functions:

__device__ __host__ inline TO fScoreOnGPU(TV genome[NB_SIN*3], int nNbSamples, int nNbSin){

TO y,fScore=0.0;
#ifndef __CUDA_ARCH__

for (int i=0;i<nNbSamples;i++){y=0; // writing the intialization of y here for clarity
  for(int j=0;j<nNbSin;j++)
    y+=genome[3*j+0]*sin(genome[3*j+1]*fSAMPLE[i][0]+genome[3*j+2]);
  fScore+=powf(fSAMPLE[i][1]-y,2); // square of the difference to focus on the large values
}
#else

for (int i=0;i<nNbSamples;i++){y=0; // writing the intialization of y here for clarity
  for(int j=0;j<nNbSin;j++)
    y+=genome[3*j+0]*sin(genome[3*j+1]*gpuSample[i][0]+genome[3*j+2]);
  fScore+=pow(gpuSample[i][1]-y,2); // square of the difference to focus on the large values
}

#endif

fScore/= NB_SAMPLES;
fScore=pow(fScore, .5);
return fScore;
}

\end

\User CUDA:
cudaMemcpyToSymbol(gpuSample, fSAMPLE, NB_SAMPLES*2*sizeof(TV));
\end

\Before everything else function:

int interval=setVariable("u3",1);
// meaning that if interval is not set on the command line, value 1 will be returned.
if (interval==1) {fX_MIN=5000; fX_MAX=70536;}
else if (interval==2) {fX_MIN=5000; fX_MAX=78728;}
else if (interval==3) {fX_MIN=5000; fX_MAX=86920;}
else if (interval==4) {fX_MIN=5000; fX_MAX=95112;}
else if (interval==5) {fX_MIN=5000; fX_MAX=103304;}
else {fX_MIN=5000;fX_MAX=111496;}


// We start by creating NB_SIN sines

    fTARGET_SIN[1][0]=224.796307; fTARGET_SIN[1][1]=0.268041723730465; fTARGET_SIN[1][2]=2.53040409949757;
    fTARGET_SIN[0][0]=36.470037; fTARGET_SIN[0][1]=0.267843206938707; fTARGET_SIN[0][2]=2.10950082600113;

//Multiply the frequencies by iACC_MULT
for (int j=0;j<NB_SIN;j++) 
    fTARGET_SIN[j][1]*=iACC_MULT;

// Now, we create NB_SAMPLES within [X_MIN, X_MAX[i]

for (int i=0;i<NB_SAMPLES;i++){
    fSAMPLE[i][0]=random((int)fX_MIN,(int)fX_MAX)/(TV)iACC_MULT;

// Creating Non Uniformly Sampled (NUS) x values
fSAMPLE[i][1]=0;                    
for (int j=0;j<NB_SIN;j++)          // Create y value by summing the sines
    fSAMPLE[i][1]+=fTARGET_SIN[j][0]*sin(fTARGET_SIN[j][1]*fSAMPLE[i][0]+fTARGET_SIN[j][2]);// amplitude * sin (freq * x + phase)
}
\end

\After everything else function:
printf("--------------------------------------------------------\n");
printf("NB_SAMPLES:%d,fX_MIN:%f,fx_MAX:%f,iACC_MULT:%d",NB_SAMPLES,fX_MIN,fX_MAX,iACC_MULT);

for (int j=0;j<NB_SIN;j++){
    fTARGET_SIN[j][1]/=(TV)iACC_MULT;
    bBest->Sin[j*3+1]/=(TV)iACC_MULT;
}

for (int i=0;i<NB_SIN; ++i){  // sort on the frequency 
    for (int j = i + 1; j < NB_SIN; ++j){
	if (bBest->Sin[i*3+1] > bBest->Sin[(j)*3+1]){ 
	    TV ampTemp, freqTemp, phaseTemp; 
	    ampTemp=bBest->Sin[i*3+0];freqTemp=bBest->Sin[i*3+1];phaseTemp=bBest->Sin[i*3+2];
	    bBest->Sin[i*3+0]=bBest->Sin[(j)*3+0];
	    bBest->Sin[i*3+1]=bBest->Sin[(j)*3+1];
	    bBest->Sin[i*3+2]=bBest->Sin[(j)*3+2];
	    bBest->Sin[(j)*3+0]=ampTemp;
	    bBest->Sin[(j)*3+1]=freqTemp;
	    bBest->Sin[(j)*3+2]=phaseTemp;
	} 
    }
}

printf("--------------------------------------------------------\n");
printf("Target function: \ny=%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[0][0],fTARGET_SIN[0][1],fTARGET_SIN[0][2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2]);
printf("\n--------------------------------------------------------\n");
printf("Obtained function sorted by frequency: \ny=%.11f*sin(%.11f*x+%.11f)",bBest->Sin[0],bBest->Sin[1],bBest->Sin[2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);
printf("\n--------------------------------------------------------\n");
printf("CSV format (copy/paste into a csv file):\n");
printf("\t\tTARGET\t\t\t\t\tOBTAINED (sorted by frequency)\n");
printf("Amplitude\tFrequency\tPhase\t\tAmplitude\tFrequency\tPhase\n");
for (int i=0;i<NB_SIN;i++)
 printf("%.11f\t%.11f\t%.11f\t%.11f\t%.11f\t%.11f\n",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2],bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);

printf("Amplitude error\tFrequency error\tPhase error\n");
for (int i=0;i<NB_SIN;i++)
printf("%.11f\t%.11f\t%.11f\n",(bBest->Sin[i*3+0]-fTARGET_SIN[i][0])/fTARGET_SIN[i][0],(bBest->Sin[i*3+1]-fTARGET_SIN[i][1])/(fTARGET_SIN[i][1]),(bBest->Sin[i*3+2]-fTARGET_SIN[i][2])/fTARGET_SIN[i][2]);

printf("Fitness=%f\n",bBest->fitness);
\end



\At the beginning of each generation function:
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\User classes :
GenomeClass {           // EASEA only implements single dimension arrays, so
  float Sin[NB_SIN*3];  // sin[i*3+0] = amplitude of sine i
                        // sin[i*3+1] = frequency of sine i
                        // sin[i*3+2] = phase of sine i
}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
for(int i=0; i<NB_SIN; i++){
  Genome.Sin[i*3+0]=random(MIN_AMP, MAX_AMP);
  Genome.Sin[i*3+1]=random(MIN_FREQ, MAX_FREQ);
  Genome.Sin[i*3+2]=random(MIN_PH, MAX_PH);
}
\end

\GenomeClass::crossover : // create child (initialized to parent1) out of parent1 and parent2 
int nLocus=random(1,NB_SIN);
for (int i=nLocus;i<NB_SIN;i++){ // we take parent2 genes after nLocus point
  child.Sin[i*3+0]=parent2.Sin[i*3+0];
  child.Sin[i*3+1]=parent2.Sin[i*3+1];
  child.Sin[i*3+2]=parent2.Sin[i*3+2];
}
\end

\GenomeClass::mutator: // all the values in here are found by trial and error
float fpMut=3/((float)NB_SIN);  // Probability of mutating a sine
for (int i=0;i<NB_SIN;i++)
  if (tossCoin(fpMut)){ // probability of mutating a value in a sine
/*
    if (tossCoin(1)) Genome.Sin[i*3+0]+=2.0-random(0.0, 4.0); 
    if (tossCoin(.233)) Genome.Sin[i*3+1]+=0.1-random(0.0, 0.2);
    if (tossCoin(.233)) Genome.Sin[i*3+2]+=0.4-random(0.0, 0.8);
*/

if (tossCoin(1)) Genome.Sin[i*3+0]+=2.0-random(0.0, 4.0);
    if (tossCoin(.233)) Genome.Sin[i*3+1]+=0.1-random(0.0, 0.2);
    if (tossCoin(.233)) Genome.Sin[i*3+2]+=0.4-random(0.0, 0.8);

  }

// This is a subtlety to improve the efficiency of the crossover
for (int i=0;i<NB_SIN-1;i++){  // an evo-bub sort on the frequency :-)  
  if (Genome.Sin[i*3+1]>Genome.Sin[(i+1)*3+1]){ // only one bubble goes up
    float ampTemp, freqTemp, phaseTemp; // the generations do the global sorting
    ampTemp=Genome.Sin[i*3+0];freqTemp=Genome.Sin[i*3+1];phaseTemp=Genome.Sin[i*3+2];
    Genome.Sin[i*3+0]=Genome.Sin[(i+1)*3+0];
    Genome.Sin[i*3+1]=Genome.Sin[(i+1)*3+1];
    Genome.Sin[i*3+2]=Genome.Sin[(i+1)*3+2];
    Genome.Sin[(i+1)*3+0]=ampTemp;
    Genome.Sin[(i+1)*3+1]=freqTemp;
    Genome.Sin[(i+1)*3+2]=phaseTemp;
} }
\end




\GenomeClass::evaluator: // Returns the score
  return (double) fScoreOnGPU(Genome.Sin,NB_SAMPLES,NB_SIN); 
\end

\User Makefile options:
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 2000     // NB_GEN
  Time limit: 0                   // In seconds, 0 to deactivate
  Population size : 131072  //16384 //32768 // 4096 
  Offspring size : 100% 
  Mutation probability : 1        // MUT_PROB
  Crossover probability : 1       // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 10
  Surviving parents: 100%         // percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament  7

  Elitism: weak			   // Weak (best of parents+offspring) or Strong (best of parents)
  Elite: 1
  Print stats: true			
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true			

  Remote island model: false
  IP file: ip.txt                  // File containing all the remote island's IP
  Server port : 2929               // why not
  Migration probability: 0.333 

  Save population: false
  Start from file:false
\end
