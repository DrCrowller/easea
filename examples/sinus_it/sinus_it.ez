/*_________________________________________________________

Pierre Collet 01/05/20
Note that EASEA filenames cannot contain dashes "-" but they
can contain underscores "_" as is the case with sinus_it.ez
__________________________________________________________*/

\User declarations :
#define NB_SIN 5              // but you can try a different value

#define MIN_AMP 1.0           // 3 parameters for each sine: amplitude, frequency, phase
#define MAX_AMP 100.0         // The range of these parameters is set here
#define MIN_FREQ 1.0
#define MAX_FREQ 10.0
#define MIN_PH 0.0
#define MAX_PH 6.283185308    // 2*PI

#define NB_SAMPLES 1024       // number of samples to be created
#define X_MIN 0.0             // Sampling interval: x values are taken in
#define X_MAX 30.0            // [X_MIN, X_MAX[

float fSAMPLE[NB_SAMPLES][2]; //  2nd dimension is x value [0] and y value [1]
float fTARGET_SIN[NB_SIN][3]; // [0] = amplitude, [1] = frequence, [2] = phase

/* Please remove comments below if you use QAES.tpl */
/*
#define NB_VARIABLES NB_SIN*3
#define NB_OBJECTIVES 1
TBoundary setBoundaryLocal(const size_t dimension)
{
        TBoundary boundary(dimension);
        for (size_t i = 0; i < NB_SIN; ++i)
        {
                boundary[i*3+0].first = MIN_AMP;
                boundary[i*3+0].second = MAX_AMP;
		boundary[i*3+1].first = MIN_FREQ;
		boundary[i*3+1].second = MAX_FREQ;
		boundary[i*3+2].first = MIN_PH;
		boundary[i*3+2].second = MAX_PH;
        }

        return boundary;
}
TP m_problem(NB_OBJECTIVES, NB_VARIABLES, setBoundaryLocal(NB_VARIABLES));
*/


\end

\User functions:
\end

\User CUDA:
\end

\Before everything else function:
// We start by creating NB_SIN sines
/*
// this code will always create a new set of sines
for (int i=0;i<NB_SIN;i++){
  fTARGET_SIN[i][0]=random(MIN_AMP, MAX_AMP);
  fTARGET_SIN[i][1]=random(MIN_FREQ, MAX_FREQ);
  fTARGET_SIN[i][2]=random(MIN_PH, MAX_PH);
}
// But for experimenting, it may be nicer to have a fixed set of sines
// The values below have been obtained with seed 2 ($ ./sinus_it -- seed 2)
*/
fTARGET_SIN[0][0]=44.163494110; fTARGET_SIN[0][1]=2.665738821; fTARGET_SIN[0][2]=0.162899300;
fTARGET_SIN[1][0]=32.733108521; fTARGET_SIN[1][1]=3.973013401; fTARGET_SIN[1][2]=0.970291436;
fTARGET_SIN[2][0]=44.096916199; fTARGET_SIN[2][1]=5.362741947; fTARGET_SIN[2][2]=2.641248941;
fTARGET_SIN[3][0]=93.222541809; fTARGET_SIN[3][1]=5.946962357; fTARGET_SIN[3][2]=5.954767227;
fTARGET_SIN[4][0]=21.260215759; fTARGET_SIN[4][1]=7.289764404; fTARGET_SIN[4][2]=3.890994310;
// ./sinus_it --nbCPUThreads 20 --seed 1588506683     gives a very good result for these sines

// Now, we create NB_SAMPLES within [X_MIN, X_MAX[
for (int i=0;i<NB_SAMPLES;i++){
  fSAMPLE[i][0]=random(X_MIN, X_MAX); // Creating Non Uniformly Sampled (NUS) x values
  fSAMPLE[i][1]=0;                    
  for (int j=0;j<NB_SIN;j++)          // Create y value by summing the sines
    fSAMPLE[i][1]+=fTARGET_SIN[j][0]*sin(fTARGET_SIN[j][1]*fSAMPLE[i][0]+fTARGET_SIN[j][2]);
                  // amplitude * sin (freq * x + phase)
}
\end

\After everything else function:
printf("--------------------------------------------------------\n");
printf("Target function: \ny=%f*sin(%f*x+%f)",fTARGET_SIN[0][0],fTARGET_SIN[0][1],fTARGET_SIN[0][2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%f*sin(%f*x+%f)",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2]);
printf("\n--------------------------------------------------------\n");
printf("Obtained function sorted by frequency: \ny=%f*sin(%f*x+%f)",bBest->Sin[0],bBest->Sin[1],bBest->Sin[2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%f*sin(%f*x+%f)",bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);
printf("\n--------------------------------------------------------\n");
printf("CSV format (copy/paste into a csv file):\n");
printf("\t\tTARGET\t\t\t\t\tOBTAINED (sorted by frequency)\n");
printf("Amplitude\tFrequency\tPhase\t\tAmplitude\tFrequency\tPhase\n");
for (int i=0;i<NB_SIN;i++)
  printf("%.9f\t%.9f\t%.9f\t%.9f\t%.9f\t%.9f\n",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2],bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);
printf("Fitness=%f\n",bBest->fitness);
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\User classes :
GenomeClass {           // EASEA only implements single dimension arrays, so
  float Sin[NB_SIN*3];  // sin[i*3+0] = amplitude of sine i
                        // sin[i*3+1] = frequency of sine i
                        // sin[i*3+2] = phase of sine i
}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
for(int i=0; i<NB_SIN; i++){
  Genome.Sin[i*3+0]=random(MIN_AMP, MAX_AMP);
  Genome.Sin[i*3+1]=random(MIN_FREQ, MAX_FREQ);
  Genome.Sin[i*3+2]=random(MIN_PH, MAX_PH);
}
\end

\GenomeClass::crossover : // create child (initialized to parent1) out of parent1 and parent2 
int nLocus=random(1,NB_SIN);
for (int i=nLocus;i<NB_SIN;i++){ // we take parent2 genes after nLocus point
  child.Sin[i*3+0]=parent2.Sin[i*3+0];
  child.Sin[i*3+1]=parent2.Sin[i*3+1];
  child.Sin[i*3+2]=parent2.Sin[i*3+2];
}
\end

\GenomeClass::mutator: // all the values in here are found by trial and error
float fpMut=3/((float)NB_SIN);  // Probability of mutating a sine
for (int i=0;i<NB_SIN;i++)
  if (tossCoin(fpMut)){ // probability of mutating a value in a sine
    if (tossCoin(1)) Genome.Sin[i*3+0]+=2.0-random(0.0, 4.0); 
    if (tossCoin(.233)) Genome.Sin[i*3+1]+=0.1-random(0.0, 0.2);
    if (tossCoin(.233)) Genome.Sin[i*3+2]+=0.4-random(0.0, 0.8);
  }

// This is a subtlety to improve the efficiency of the crossover
for (int i=0;i<NB_SIN-1;i++){  // an evo-bub sort on the frequency :-)  
  if (Genome.Sin[i*3+1]>Genome.Sin[(i+1)*3+1]){ // only one bubble goes up
    float ampTemp, freqTemp, phaseTemp; // the generations do the global sorting
    ampTemp=Genome.Sin[i*3+0];freqTemp=Genome.Sin[i*3+1];phaseTemp=Genome.Sin[i*3+2];
    Genome.Sin[i*3+0]=Genome.Sin[(i+1)*3+0];
    Genome.Sin[i*3+1]=Genome.Sin[(i+1)*3+1];
    Genome.Sin[i*3+2]=Genome.Sin[(i+1)*3+2];
    Genome.Sin[(i+1)*3+0]=ampTemp;
    Genome.Sin[(i+1)*3+1]=freqTemp;
    Genome.Sin[(i+1)*3+2]=phaseTemp;
} }
\end

\GenomeClass::evaluator: // Returns the score
float y,fScore=0.0;
for (int i=0;i<NB_SAMPLES;i++){y=0; // writing the intialization of y here for clarity
  for(int j=0;j<NB_SIN;j++)
    y+=Genome.Sin[3*j+0]*sin(Genome.Sin[3*j+1]*fSAMPLE[i][0]+Genome.Sin[3*j+2]);
  fScore+=powf(fSAMPLE[i][1]-y,2); // square of the difference to focus on the large values
}
return fScore/NB_SAMPLES; // to normalize the sum

\end

\User Makefile options:
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 100     // NB_GEN
  Time limit: 0                   // In seconds, 0 to deactivate
  Population size : 4096 
  Offspring size : 100% 
  Mutation probability : 1        // MUT_PROB
  Crossover probability : 1       // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 10
  Surviving parents: 100%         // percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: weak			   // Weak (best of parents+offspring) or Strong (best of parents)
  Elite: 1
  Print stats: true			
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true			

  Remote island model: false
  IP file: ip.txt                  // File containing all the remote island's IP
  Server port : 2929               // why not
  Migration probability: 0.333 

  Save population: false
  Start from file:false
\end
