/*_________________________________________________________

Pierre Collet 01/05/20
Note that EASEA filenames cannot contain dashes "-" but they
can contain underscores "_" as is the case with sinus_it.ez
__________________________________________________________*/

\User declarations :
#define NB_SIN 30              // but you can try a different value


int nACC_MULT=1024*1024;

#define PI  3.14159265358979323846
 #define MIN_AMP 10.0 // At least one tenths the minimum sine amplitude
 #define MAX_AMP 100000.0 // At least ten times the maximum sine amplitude
 #define MIN_FREQ 0.26*nACC_MULT
 #define MAX_FREQ 0.27*nACC_MULT
 #define MIN_PH 0.0
 #define MAX_PH 2*PI



/*
#define MIN_AMP 1.0 // 6575.0           // 3 parameters for each sine: amplitude, frequency, phase
#define MAX_AMP 10000000.0         // The range of these parameters is set here
#define MIN_FREQ 0.0*nACC_MULT
#define MAX_FREQ PI*nACC_MULT
#define MIN_PH 0
#define MAX_PH 2*PI //6.283185308    // 2*PI
*/
#define NB_SAMPLES 4*1024 //16384 //8192 //131072 //8192 //4096       // number of samples to be created

float fX_MIN;
float fX_MAX;

float fSAMPLE[NB_SAMPLES][2]; //  2nd dimension is x value [0] and y value [1]
float fTARGET_SIN[NB_SIN][3]; // [0] = amplitude, [1] = frequence, [2] = phase


#define NB_VARIABLES NB_SIN*3
#define NB_OBJECTIVES 1
TBoundary setBoundaryLocal(const size_t dimension)
{
        TBoundary boundary(dimension);
        for (size_t i = 0; i < NB_SIN; ++i)
        {
                boundary[i*3+0].first = MIN_AMP;//coco_problem_get_smallest_values_of_interest(PROBLEM)[i];

                boundary[i*3+0].second = MAX_AMP;//coco_problem_get_largest_values_of_interest(PROBLEM)[i];

boundary[i*3+1].first = MIN_FREQ;
boundary[i*3+1].second = MAX_FREQ;
boundary[i*3+2].first = MIN_PH;
boundary[i*3+2].second = MAX_PH;

        }

        return boundary;
}
TP m_problem(NB_OBJECTIVES, NB_VARIABLES, setBoundaryLocal(NB_VARIABLES));





__device__  float gpuSample[NB_SAMPLES][2];

\end

\User functions:

__device__ __host__ inline float fScoreOnGPU(float genome[NB_SIN*3], int nNbSamples, int nNbSin){

float y,fScore=0.0;
#ifndef __CUDA_ARCH__

for (int i=0;i<nNbSamples;i++){y=0.0; // writing the intialization of y here for clarity
  for(int j=0;j<nNbSin;j++)
    y+=genome[3*j+0]*sin(genome[3*j+1]*fSAMPLE[i][0]+genome[3*j+2]);
  fScore+=powf(fSAMPLE[i][1]-y,2); // square of the difference to focus on the large values
}
#else

for (int i=0;i<nNbSamples;i++){y=0.0; // writing the intialization of y here for clarity
  for(int j=0;j<nNbSin;j++)
    y+=genome[3*j+0]*sin(genome[3*j+1]*gpuSample[i][0]+genome[3*j+2]);
  fScore+=powf(gpuSample[i][1]-y,2); // square of the difference to focus on the large values
}

#endif


//return fScore/NB_SAMPLES; // to normalize the sum
 fScore/= NB_SAMPLES;
fScore=pow(fScore, .5);
return fScore;
}

\end

\User CUDA:
cudaMemcpyToSymbol(gpuSample, fSAMPLE, NB_SAMPLES*2*sizeof(int));
\end

\Before everything else function:

int interval=setVariable("u3",1);
// meaning that if interval is not set on the command line, value 1 will be returned.
if (interval==1) {fX_MIN=5000; fX_MAX=70536;}
else if (interval==2) {fX_MIN=5000; fX_MAX=78728;}
else if (interval==3) {fX_MIN=5000; fX_MAX=86920;}
else if (interval==4) {fX_MIN=5000; fX_MAX=95112;}
else if (interval==5) {fX_MIN=5000; fX_MAX=103304;}
else {fX_MIN=5000;fX_MAX=111496;}


// We start by creating NB_SIN sines
/*
// this code will always create a new set of sines
for (int i=0;i<NB_SIN;i++){
  fTARGET_SIN[i][0]=random(MIN_AMP, MAX_AMP);
  fTARGET_SIN[i][1]=random(MIN_FREQ, MAX_FREQ);
  fTARGET_SIN[i][2]=random(MIN_PH, MAX_PH);
}
// But for experimenting, it may be nicer to have a fixed set of sines
// The values below have been obtained with seed 2 ($ ./sinus_it -- seed 2)
*/

fTARGET_SIN[29][0]=100000.0; fTARGET_SIN[29][1]=0.269036561; fTARGET_SIN[29][2]=3.34788863253907;
fTARGET_SIN[28][0]=6575.93640899999; fTARGET_SIN[28][1]=0.26883782722871; fTARGET_SIN[28][2]=3.35607924274151;
fTARGET_SIN[27][0]=68139.08824000001; fTARGET_SIN[27][1]=0.26883656847244647; fTARGET_SIN[27][2]=4.483455040543435;
fTARGET_SIN[26][0]=204.202770999999; fTARGET_SIN[26][1]=0.268639386844749; fTARGET_SIN[26][2]=5.55357670028002;
fTARGET_SIN[25][0]=4480.783112; fTARGET_SIN[25][1]=0.268638129946075; fTARGET_SIN[25][2]=4.04288516642772;
fTARGET_SIN[24][0]=22846.1898; fTARGET_SIN[24][1]=0.268636873; fTARGET_SIN[24][2]=0.0223298575531112;
fTARGET_SIN[23][0]=783.689639; fTARGET_SIN[23][1]=0.268636291933426; fTARGET_SIN[23][2]=0.0770012735908158;
fTARGET_SIN[22][0]=3048.648542; fTARGET_SIN[22][1]=0.268439641350763; fTARGET_SIN[22][2]=4.9811107863076;
fTARGET_SIN[21][0]=22.156166; fTARGET_SIN[21][1]=0.268439470168061; fTARGET_SIN[21][2]=5.65127986591788;
fTARGET_SIN[20][0]=1502.350913; fTARGET_SIN[20][1]=0.268438729120262; fTARGET_SIN[20][2]=3.40589597387381;
fTARGET_SIN[19][0]=180.383644; fTARGET_SIN[19][1]=0.268438261846807; fTARGET_SIN[19][2]=1.58488123092724;
fTARGET_SIN[18][0]=1820.330104; fTARGET_SIN[18][1]=0.26843796337252; fTARGET_SIN[18][2]=0.837780324782093;
fTARGET_SIN[17][0]=12.211677; fTARGET_SIN[17][1]=0.268437792191957; fTARGET_SIN[17][2]=5.50569490283791;
fTARGET_SIN[16][0]=5024.329689; fTARGET_SIN[16][1]=0.268437474058823; fTARGET_SIN[16][2]=3.0180140540959;
fTARGET_SIN[15][0]=10.527424; fTARGET_SIN[15][1]=0.268242021306119; fTARGET_SIN[15][2]=6.15733605952665;
fTARGET_SIN[14][0]=46.652553; fTARGET_SIN[14][1]=0.268240877263999; fTARGET_SIN[14][2]=2.85564911968626;
fTARGET_SIN[13][0]=1022.173983; fTARGET_SIN[13][1]=0.268240534969381; fTARGET_SIN[13][2]=5.05911262303754;
fTARGET_SIN[12][0]=11.8619139999999; fTARGET_SIN[12][1]=0.268240410718753; fTARGET_SIN[12][2]=4.69499345870459;
fTARGET_SIN[11][0]=330.396725; fTARGET_SIN[11][1]=0.26823962409161; fTARGET_SIN[11][2]=0.223169049356245;
fTARGET_SIN[10][0]=610.33407; fTARGET_SIN[10][1]=0.268238859479379; fTARGET_SIN[10][2]=3.34970253886262;
fTARGET_SIN[9][0]=815.126772; fTARGET_SIN[9][1]=0.268238370891273; fTARGET_SIN[9][2]=4.16269439654983;
fTARGET_SIN[8][0]=20.936204; fTARGET_SIN[8][1]=0.268238280074361; fTARGET_SIN[8][2]=2.87943103086207;
fTARGET_SIN[7][0]=81.444394; fTARGET_SIN[7][1]=0.268042211562859; fTARGET_SIN[7][2]=0.887749414572265;
fTARGET_SIN[6][0]=224.796307; fTARGET_SIN[6][1]=0.268041723730465; fTARGET_SIN[6][2]=2.53040409949757;
fTARGET_SIN[5][0]=40.13518; fTARGET_SIN[5][1]=0.268041302031501; fTARGET_SIN[5][2]=2.55363516580658;
fTARGET_SIN[4][0]=134.224552; fTARGET_SIN[4][1]=0.268040050683572; fTARGET_SIN[4][2]=6.06948393085575;
fTARGET_SIN[3][0]=104.031038; fTARGET_SIN[3][1]=0.268039562859044; fTARGET_SIN[3][2]=0.438069777614316;
fTARGET_SIN[2][0]=14.782462; fTARGET_SIN[2][1]=0.267844456449371; fTARGET_SIN[2][2]=2.27481876761963;
fTARGET_SIN[1][0]=36.470037; fTARGET_SIN[1][1]=0.267843206938707; fTARGET_SIN[1][2]=2.10950082600113;
fTARGET_SIN[0][0]=10.876657; fTARGET_SIN[0][1]=0.267841049306394; fTARGET_SIN[0][2]=1.46465526454553;




//Multiply the frequencies by nACC_MULT
for (int j=0;j<NB_SIN;j++) 
fTARGET_SIN[j][1]*=nACC_MULT;

// Now, we create NB_SAMPLES within [X_MIN, X_MAX[i]

for (int i=0;i<NB_SAMPLES;i++){
fSAMPLE[i][0]=random((int)fX_MIN,(int)fX_MAX)/(float)nACC_MULT;

// Creating Non Uniformly Sampled (NUS) x values
 fSAMPLE[i][1]=0;                    
  for (int j=0;j<NB_SIN;j++)          // Create y value by summing the sines
    fSAMPLE[i][1]+=fTARGET_SIN[j][0]*sin(fTARGET_SIN[j][1]*fSAMPLE[i][0]+fTARGET_SIN[j][2]);
                  // amplitude * sin (freq * x + phase)
}
\end

/*\After everything else function:
printf("--------------------------------------------------------\n");
printf("NB_SAMPLES:%d,fX_MIN:%f,fx_MAX:%f,nACC_MULT:%d",NB_SAMPLES,fX_MIN,fX_MAX,nACC_MULT);

for (int j=0;j<NB_SIN;j++){
fTARGET_SIN[j][1]/=(float)nACC_MULT;
bBest->Sin[j*3+1]/=(float)nACC_MULT;
}

for (int i=0;i<NB_SIN-1;i++){  // an evo-bub sort on the frequency :-)
  if (bBest->Sin[i*3+1] > bBest->Sin[(i+1)*3+1]){ // only one bubble goes up
    float ampTemp, freqTemp, phaseTemp; // the generations do the global sorting
    ampTemp=bBest->Sin[i*3+0];freqTemp=bBest->Sin[i*3+1];phaseTemp=bBest->Sin[i*3+2];
    bBest->Sin[i*3+0]=bBest->Sin[(i+1)*3+0];
    bBest->Sin[i*3+1]=bBest->Sin[(i+1)*3+1];
    bBest->Sin[i*3+2]=bBest->Sin[(i+1)*3+2];
    bBest->Sin[(i+1)*3+0]=ampTemp;
    bBest->Sin[(i+1)*3+1]=freqTemp;
    bBest->Sin[(i+1)*3+2]=phaseTemp;
} }


printf("--------------------------------------------------------\n");
printf("Target function: \ny=%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[0][0],fTARGET_SIN[0][1],fTARGET_SIN[0][2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2]);
printf("\n--------------------------------------------------------\n");
printf("Obtained function sorted by frequency: \ny=%.11f*sin(%.11f*x+%.11f)",bBest->Sin[0],bBest->Sin[1],bBest->Sin[2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);
printf("\n--------------------------------------------------------\n");
printf("CSV format (copy/paste into a csv file):\n");
printf("\t\tTARGET\t\t\t\t\tOBTAINED (sorted by frequency)\n");
printf("Amplitude\tFrequency\tPhase\t\tAmplitude\tFrequency\tPhase\n");
for (int i=0;i<NB_SIN;i++)
 printf("%.11f\t%.11f\t%.11f\t%.11f\t%.11f\t%.11f\n",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2],bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);

printf("Amplitude error\tFrequency error\tPhase error\n");
for (int i=0;i<NB_SIN;i++)
printf("%.11f\t%.11f\t%.11f\n",(bBest->Sin[i*3+0]-fTARGET_SIN[i][0])/fTARGET_SIN[i][0],(bBest->Sin[i*3+1]-fTARGET_SIN[i][1])/(fTARGET_SIN[i][1]),(bBest->Sin[i*3+2]-fTARGET_SIN[i][2])/fTARGET_SIN[i][2]);

printf("Fitness=%f\n",bBest->fitness);
\end
*/
\After everything else function:
printf("--------------------------------------------------------\n");
printf("NB_SAMPLES:%d,fX_MIN:%f,fx_MAX:%f,nACC_MULT:%d",NB_SAMPLES,fX_MIN,fX_MAX,nACC_MULT);
for (int j=0;j<NB_SIN;j++){
fTARGET_SIN[j][1]/=(float)nACC_MULT;
bBest->Sin[j*3+1]/=(float)nACC_MULT;
}
int minFreq;
for (int i=0;i<NB_SIN; ++i){  // an evo-bub sort on the frequency :-)
//minFreq = i;
for (int j = i + 1; j < NB_SIN; ++j){
  if (bBest->Sin[i*3+1] > bBest->Sin[(j)*3+1]){ // only one bubble goes up
    float ampTemp, freqTemp, phaseTemp; // the generations do the global sorting
    ampTemp=bBest->Sin[i*3+0];freqTemp=bBest->Sin[i*3+1];phaseTemp=bBest->Sin[i*3+2];
    bBest->Sin[i*3+0]=bBest->Sin[(j)*3+0];
    bBest->Sin[i*3+1]=bBest->Sin[(j)*3+1];
    bBest->Sin[i*3+2]=bBest->Sin[(j)*3+2];
    bBest->Sin[(j)*3+0]=ampTemp;
    bBest->Sin[(j)*3+1]=freqTemp;
    bBest->Sin[(j)*3+2]=phaseTemp;
} }
}
printf("--------------------------------------------------------\n");
printf("Target function: \ny=%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[0][0],fTARGET_SIN[0][1],fTARGET_SIN[0][2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2]);
printf("\n--------------------------------------------------------\n");
printf("Obtained function sorted by frequency: \ny=%.11f*sin(%.11f*x+%.11f)",bBest->Sin[0],bBest->Sin[1],bBest->Sin[2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);
printf("\n--------------------------------------------------------\n");
printf("CSV format (copy/paste into a csv file):\n");
printf("\t\tTARGET\t\t\t\t\tOBTAINED (sorted by frequency)\n");
printf("Amplitude\tFrequency\tPhase\t\tAmplitude\tFrequency\tPhase\n");
for (int i=0;i<NB_SIN;i++)
 printf("%.11f\t%.11f\t%.11f\t%.11f\t%.11f\t%.11f\n",fTARGET_SIN[i][0],fTARGET_SIN[i][1],fTARGET_SIN[i][2],bBest->Sin[i*3+0],bBest->Sin[i*3+1],bBest->Sin[i*3+2]);

printf("Amplitude error\tFrequency error\tPhase error\n");
for (int i=0;i<NB_SIN;i++)
printf("%.11f\t%.11f\t%.11f\n",(bBest->Sin[i*3+0]-fTARGET_SIN[i][0])/fTARGET_SIN[i][0],(bBest->Sin[i*3+1]-fTARGET_SIN[i][1])/(fTARGET_SIN[i][1]),(bBest->Sin[i*3+2]-fTARG

printf("Fitness=%f\n",bBest->fitness);
\end



/*
\After everything else function:
printf("--------------------------------------------------------\n");
printf("%d,%f,%f",NB_SAMPLES,fX_MIN,fX_MAX);
printf("--------------------------------------------------------\n");
printf("Target function: \ny=%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[0][0],fTARGET_SIN[0][1]/(float)nACC_MULT,fTARGET_SIN[0][2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",fTARGET_SIN[i][0],fTARGET_SIN[i][1]/(float)nACC_MULT,fTARGET_SIN[i][2]);
printf("\n--------------------------------------------------------\n");
printf("Obtained function sorted by frequency: \ny=%.11f*sin(%.11f*x+%.11f)",bBest->Sin[0],bBest->Sin[1]/(float)nACC_MULT,bBest->Sin[2]);
for (int i=1;i<NB_SIN;i++)
  printf("+%.11f*sin(%.11f*x+%.11f)",bBest->Sin[i*3+0],bBest->Sin[i*3+1]/(float)nACC_MULT,bBest->Sin[i*3+2]);
printf("\n--------------------------------------------------------\n");
printf("CSV format (copy/paste into a csv file):\n");
printf("\t\tTARGET\t\t\t\t\tOBTAINED (sorted by frequency)\n");
printf("Amplitude\tFrequency\tPhase\t\tAmplitude\tFrequency\tPhase\n");
for (int i=0;i<NB_SIN;i++)
 printf("%.11f\t%.11f\t%.11f\t%.11f\t%.11f\t%.11f\n",fTARGET_SIN[i][0],fTARGET_SIN[i][1]/(float)nACC_MULT,fTARGET_SIN[i][2],bBest->Sin[i*3+0],bBest->Sin[i*3+1]/(float)nACC_MULT,bBest->Sin[i*3+2]);

printf("Amplitude error\tFrequency error\tPhase error\n");
for (int i=0;i<NB_SIN;i++)
printf("%.11f\t%.11f\t%.11f\n",(bBest->Sin[i*3+0]-fTARGET_SIN[i][0])/fTARGET_SIN[i][0],(bBest->Sin[i*3+1]/(float)nACC_MULT-fTARGET_SIN[i][1]/(float)nACC_MULT)/(fTARGET_SIN[i][1]/(float)nACC_MULT),(bBest->Sin[i*3+2]-fTARGET_SIN[i][2])/fTARGET_SIN[i][2]);

printf("Fitness=%f\n",bBest->fitness);
\end
*/


\At the beginning of each generation function:
\end

\At the end of each generation function:
  //cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
  //cout << "At each generation before replacement function called" << endl;
\end

\User classes :
GenomeClass {           // EASEA only implements single dimension arrays, so
  float Sin[NB_SIN*3];  // sin[i*3+0] = amplitude of sine i
                        // sin[i*3+1] = frequency of sine i
                        // sin[i*3+2] = phase of sine i
}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
for(int i=0; i<NB_SIN; i++){
  Genome.Sin[i*3+0]=random(MIN_AMP, MAX_AMP);
  Genome.Sin[i*3+1]=random(MIN_FREQ, MAX_FREQ);
  Genome.Sin[i*3+2]=random(MIN_PH, MAX_PH);
}
\end

\GenomeClass::crossover : // create child (initialized to parent1) out of parent1 and parent2 
int nLocus=random(1,NB_SIN);
for (int i=nLocus;i<NB_SIN;i++){ // we take parent2 genes after nLocus point
  child.Sin[i*3+0]=parent2.Sin[i*3+0];
  child.Sin[i*3+1]=parent2.Sin[i*3+1];
  child.Sin[i*3+2]=parent2.Sin[i*3+2];
}
\end

\GenomeClass::mutator: // all the values in here are found by trial and error
float fpMut=3/((float)NB_SIN);  // Probability of mutating a sine
for (int i=0;i<NB_SIN;i++)
  if (tossCoin(fpMut)){ // probability of mutating a value in a sine
/*
    if (tossCoin(1)) Genome.Sin[i*3+0]+=2.0-random(0.0, 4.0); 
    if (tossCoin(.233)) Genome.Sin[i*3+1]+=0.1-random(0.0, 0.2);
    if (tossCoin(.233)) Genome.Sin[i*3+2]+=0.4-random(0.0, 0.8);
*/

if (tossCoin(1)) Genome.Sin[i*3+0]+=2.0-random(0.0, 4.0);
    if (tossCoin(.233)) Genome.Sin[i*3+1]+=0.1-random(0.0, 0.2);
    if (tossCoin(.233)) Genome.Sin[i*3+2]+=0.4-random(0.0, 0.8);

  }
/*
// This is a subtlety to improve the efficiency of the crossover
for (int i=0;i<NB_SIN-1;i++){  // an evo-bub sort on the frequency :-)  
  if (Genome.Sin[i*3+1]>Genome.Sin[(i+1)*3+1]){ // only one bubble goes up
    float ampTemp, freqTemp, phaseTemp; // the generations do the global sorting
    ampTemp=Genome.Sin[i*3+0];freqTemp=Genome.Sin[i*3+1];phaseTemp=Genome.Sin[i*3+2];
    Genome.Sin[i*3+0]=Genome.Sin[(i+1)*3+0];
    Genome.Sin[i*3+1]=Genome.Sin[(i+1)*3+1];
    Genome.Sin[i*3+2]=Genome.Sin[(i+1)*3+2];
    Genome.Sin[(i+1)*3+0]=ampTemp;
    Genome.Sin[(i+1)*3+1]=freqTemp;
    Genome.Sin[(i+1)*3+2]=phaseTemp;
} }
*/
\end




\GenomeClass::evaluator: // Returns the score
  return (double) fScoreOnGPU(Genome.Sin,NB_SAMPLES,NB_SIN); 
\end

\User Makefile options:
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 2000     // NB_GEN
  Time limit: 0                   // In seconds, 0 to deactivate
  Population size :131072 //16384 //32768 // 4096 
  Offspring size : 100% 
  Mutation probability : 1        // MUT_PROB
  Crossover probability : 1       // XOVER_PROB
  Evaluator goal : minimise       // Maximise
  Selection operator: Tournament 10
  Surviving parents: 100%         // percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament  7

  Elitism: weak			   // Weak (best of parents+offspring) or Strong (best of parents)
  Elite: 1
  Print stats: true			
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true			

  Remote island model: false
  IP file: ip.txt                  // File containing all the remote island's IP
  Server port : 2929               // why not
  Migration probability: 0.333 

  Save population: false
  Start from file:false
\end
